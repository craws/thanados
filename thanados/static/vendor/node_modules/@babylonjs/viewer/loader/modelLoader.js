import { GLTFLoaderAnimationStartMode } from "@babylonjs/loaders/glTF/glTFFileLoader";
import { Tools } from '@babylonjs/core/Misc/tools';
import { SceneLoader } from '@babylonjs/core/Loading/sceneLoader';
import { Tags } from '@babylonjs/core/Misc/tags';
import { ModelState, ViewerModel } from '../model/viewerModel';
import { getLoaderPluginByName } from './plugins/';
/**
 * An instance of the class is in charge of loading the model correctly.
 * This class will continously be expended with tasks required from the specific loaders Babylon has.
 *
 * A Model loader is unique per (Abstract)Viewer. It is being generated by the viewer
 */
var ModelLoader = /** @class */ (function () {
    /**
     * Create a new Model loader
     * @param _viewer the viewer using this model loader
     */
    function ModelLoader(_observablesManager, _configurationContainer) {
        this._observablesManager = _observablesManager;
        this._configurationContainer = _configurationContainer;
        this._disposed = false;
        this._loaders = [];
        this._loadId = 0;
        this._plugins = [];
    }
    Object.defineProperty(ModelLoader.prototype, "baseUrl", {
        get: function () {
            return this._baseUrl;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a new plugin to the loader process.
     *
     * @param plugin the plugin name or the plugin itself
     */
    ModelLoader.prototype.addPlugin = function (plugin) {
        var actualPlugin = {};
        if (typeof plugin === 'string') {
            var loadedPlugin = getLoaderPluginByName(plugin);
            if (loadedPlugin) {
                actualPlugin = loadedPlugin;
            }
        }
        else {
            actualPlugin = plugin;
        }
        if (actualPlugin && this._plugins.indexOf(actualPlugin) === -1) {
            this._plugins.push(actualPlugin);
        }
    };
    /**
     * Load a model using predefined configuration
     * @param modelConfiguration the modelConfiguration to use to load the model
     */
    ModelLoader.prototype.load = function (modelConfiguration) {
        var _this = this;
        var model = new ViewerModel(this._observablesManager, modelConfiguration, this._configurationContainer);
        model.loadId = this._loadId++;
        var filename;
        if (modelConfiguration.file) {
            this._baseUrl = "file:";
            filename = modelConfiguration.file;
        }
        else if (modelConfiguration.url) {
            filename = Tools.GetFilename(modelConfiguration.url) || modelConfiguration.url;
            this._baseUrl = modelConfiguration.root || Tools.GetFolderPath(modelConfiguration.url);
        }
        if (!filename || !this._baseUrl) {
            model.state = ModelState.ERROR;
            Tools.Error("No URL provided");
            return model;
        }
        var plugin = modelConfiguration.loader;
        var scene = model.rootMesh.getScene();
        model.loader = SceneLoader.ImportMesh(undefined, this._baseUrl, filename, scene, function (meshes, particleSystems, skeletons, animationGroups) {
            meshes.forEach(function (mesh) {
                Tags.AddTagsTo(mesh, "viewerMesh");
                model.addMesh(mesh);
            });
            model.particleSystems = particleSystems;
            model.skeletons = skeletons;
            for (var _i = 0, animationGroups_1 = animationGroups; _i < animationGroups_1.length; _i++) {
                var animationGroup = animationGroups_1[_i];
                model.addAnimationGroup(animationGroup);
            }
            _this._checkAndRun("onLoaded", model);
            scene.executeWhenReady(function () {
                model.onLoadedObservable.notifyObservers(model);
            });
        }, function (progressEvent) {
            _this._checkAndRun("onProgress", progressEvent);
            model.onLoadProgressObservable.notifyObserversWithPromise(progressEvent);
        }, function (scene, m, exception) {
            model.state = ModelState.ERROR;
            Tools.Error("Load Error: There was an error loading the model. " + m);
            _this._checkAndRun("onError", m, exception);
            model.onLoadErrorObservable.notifyObserversWithPromise({ message: m, exception: exception });
        }, plugin);
        if (model.loader.name === "gltf") {
            var gltfLoader_1 = model.loader;
            gltfLoader_1.animationStartMode = GLTFLoaderAnimationStartMode.NONE;
            gltfLoader_1.compileMaterials = true;
            if (!modelConfiguration.file) {
                gltfLoader_1.rewriteRootURL = function (rootURL, responseURL) {
                    return modelConfiguration.root || Tools.GetFolderPath(responseURL || modelConfiguration.url || '');
                };
            }
            // if ground is set to "mirror":
            if (this._configurationContainer
                && this._configurationContainer.configuration
                && this._configurationContainer.configuration.ground
                && typeof this._configurationContainer.configuration.ground === 'object'
                && this._configurationContainer.configuration.ground.mirror) {
                gltfLoader_1.useClipPlane = true;
            }
            Object.keys(gltfLoader_1).filter(function (name) { return name.indexOf('on') === 0 && name.indexOf('Observable') !== -1; }).forEach(function (functionName) {
                gltfLoader_1[functionName].add(function (payload) {
                    _this._checkAndRun(functionName.replace("Observable", ''), payload);
                });
            });
            gltfLoader_1.onParsedObservable.add(function (data) {
                if (data && data.json && data.json['asset']) {
                    model.loadInfo = data.json['asset'];
                }
            });
            gltfLoader_1.onCompleteObservable.add(function () {
                model.loaderDone = true;
            });
        }
        else {
            model.loaderDone = true;
        }
        this._checkAndRun("onInit", model.loader, model);
        this._loaders.push(model.loader);
        return model;
    };
    ModelLoader.prototype.cancelLoad = function (model) {
        var loader = model.loader || this._loaders[model.loadId];
        // ATM only available in the GLTF Loader
        if (loader && loader.name === "gltf") {
            var gltfLoader = loader;
            gltfLoader.dispose();
            model.state = ModelState.CANCELED;
        }
        else {
            Tools.Warn("This type of loader cannot cancel the request");
        }
    };
    /**
     * dispose the model loader.
     * If loaders are registered and are in the middle of loading, they will be disposed and the request(s) will be cancelled.
     */
    ModelLoader.prototype.dispose = function () {
        this._loaders.forEach(function (loader) {
            if (loader.name === "gltf") {
                loader.dispose();
            }
        });
        this._loaders.length = 0;
        this._disposed = true;
    };
    ModelLoader.prototype._checkAndRun = function (functionName) {
        var _this = this;
        var payload = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            payload[_i - 1] = arguments[_i];
        }
        if (this._disposed) {
            return;
        }
        this._plugins.filter(function (p) { return p[functionName]; }).forEach(function (plugin) {
            try {
                plugin[functionName].apply(_this, payload);
            }
            catch (e) { }
        });
    };
    return ModelLoader;
}());
export { ModelLoader };
//# sourceMappingURL=modelLoader.js.map