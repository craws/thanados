{"version":3,"file":"eventManager.js","sourceRoot":"","sources":["../../../../sourceES6/viewer/src/templating/eventManager.ts"],"names":[],"mappings":"AAEA;;;GAGG;AACH;IAII,sBAAoB,gBAAiC;QAArD,iBAKC;QALmB,qBAAgB,GAAhB,gBAAgB,CAAiB;QACjD,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC;QAC9B,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,GAAG,CAAC,UAAC,SAAS;YACjD,KAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;OAQG;IACI,uCAAgB,GAAvB,UAAwB,YAAoB,EAAE,QAA4C,EAAE,SAAkB,EAAE,QAAiB;QAC7H,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,EAAE;YACzC,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC;SAC/C;QACD,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC;YACxC,SAAS,WAAA;YACT,QAAQ,UAAA;YACR,QAAQ,UAAA;SACX,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;OAQG;IACI,yCAAkB,GAAzB,UAA0B,YAAoB,EAAE,QAA4C,EAAE,SAAkB,EAAE,QAAiB;QAC/H,IAAI,YAAY,GAAG,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;QAChE,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,UAAC,WAAW,IAAK,OAAA,CAAC,CAAC,WAAW,CAAC,SAAS,IAAI,WAAW,CAAC,SAAS,KAAK,SAAS,CAAC,IAAI,CAAC,CAAC,WAAW,CAAC,QAAQ,IAAI,WAAW,CAAC,QAAQ,KAAK,QAAQ,CAAC,EAA/H,CAA+H,CAAC,CAAC;IACnN,CAAC;IAEO,sCAAe,GAAvB,UAAwB,IAAmB;QACvC,IAAI,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;QACtC,IAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAChC,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE7B,IAAI,YAAY,GAAG,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;QAChE,YAAY,CAAC,MAAM,CAAC,UAAC,WAAW,IAAK,OAAA,CAAC,CAAC,WAAW,CAAC,SAAS,IAAI,WAAW,CAAC,SAAS,KAAK,SAAS,CAAC,IAAI,CAAC,CAAC,WAAW,CAAC,QAAQ,IAAI,WAAW,CAAC,QAAQ,KAAK,QAAQ,CAAC,EAA/H,CAA+H,CAAC,CAAC,OAAO,CAAC,UAAC,WAAW;YACtL,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACI,8BAAO,GAAd;QACI,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC;IAClC,CAAC;IACL,mBAAC;AAAD,CAAC,AA9DD,IA8DC","sourcesContent":["import { EventCallback, TemplateManager } from \"./templateManager\";\r\n\r\n/**\r\n * The EventManager is in charge of registering user interctions with the viewer.\r\n * It is used in the TemplateManager\r\n */\r\nexport class EventManager {\r\n\r\n    private _callbacksContainer: { [key: string]: Array<{ eventType?: string, selector?: string, callback: (eventData: EventCallback) => void }> };\r\n\r\n    constructor(private _templateManager: TemplateManager) {\r\n        this._callbacksContainer = {};\r\n        this._templateManager.onEventTriggered.add((eventData) => {\r\n            this._eventTriggered(eventData);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Register a new callback to a specific template.\r\n     * The best example for the usage can be found in the DefaultViewer\r\n     *\r\n     * @param templateName the templateName to register the event to\r\n     * @param callback The callback to be executed\r\n     * @param eventType the type of event to register\r\n     * @param selector an optional selector. if not defined the parent object in the template will be selected\r\n     */\r\n    public registerCallback(templateName: string, callback: (eventData: EventCallback) => void, eventType?: string, selector?: string) {\r\n        if (!this._callbacksContainer[templateName]) {\r\n            this._callbacksContainer[templateName] = [];\r\n        }\r\n        this._callbacksContainer[templateName].push({\r\n            eventType,\r\n            callback,\r\n            selector\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This will remove a registered event from the defined template.\r\n     * Each one of the variables apart from the template name are optional, but one must be provided.\r\n     *\r\n     * @param templateName the templateName\r\n     * @param callback the callback to remove (optional)\r\n     * @param eventType the event type to remove (optional)\r\n     * @param selector the selector from which to remove the event (optional)\r\n     */\r\n    public unregisterCallback(templateName: string, callback: (eventData: EventCallback) => void, eventType?: string, selector?: string) {\r\n        let callbackDefs = this._callbacksContainer[templateName] || [];\r\n        this._callbacksContainer[templateName] = callbackDefs.filter((callbackDef) => (!callbackDef.eventType || callbackDef.eventType === eventType) && (!callbackDef.selector || callbackDef.selector === selector));\r\n    }\r\n\r\n    private _eventTriggered(data: EventCallback) {\r\n        let templateName = data.template.name;\r\n        let eventType = data.event.type;\r\n        let selector = data.selector;\r\n\r\n        let callbackDefs = this._callbacksContainer[templateName] || [];\r\n        callbackDefs.filter((callbackDef) => (!callbackDef.eventType || callbackDef.eventType === eventType) && (!callbackDef.selector || callbackDef.selector === selector)).forEach((callbackDef) => {\r\n            callbackDef.callback(data);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose the event manager\r\n     */\r\n    public dispose() {\r\n        this._callbacksContainer = {};\r\n    }\r\n}"]}