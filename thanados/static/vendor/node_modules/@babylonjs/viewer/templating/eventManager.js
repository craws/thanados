/**
 * The EventManager is in charge of registering user interctions with the viewer.
 * It is used in the TemplateManager
 */
var EventManager = /** @class */ (function () {
    function EventManager(_templateManager) {
        var _this = this;
        this._templateManager = _templateManager;
        this._callbacksContainer = {};
        this._templateManager.onEventTriggered.add(function (eventData) {
            _this._eventTriggered(eventData);
        });
    }
    /**
     * Register a new callback to a specific template.
     * The best example for the usage can be found in the DefaultViewer
     *
     * @param templateName the templateName to register the event to
     * @param callback The callback to be executed
     * @param eventType the type of event to register
     * @param selector an optional selector. if not defined the parent object in the template will be selected
     */
    EventManager.prototype.registerCallback = function (templateName, callback, eventType, selector) {
        if (!this._callbacksContainer[templateName]) {
            this._callbacksContainer[templateName] = [];
        }
        this._callbacksContainer[templateName].push({
            eventType: eventType,
            callback: callback,
            selector: selector
        });
    };
    /**
     * This will remove a registered event from the defined template.
     * Each one of the variables apart from the template name are optional, but one must be provided.
     *
     * @param templateName the templateName
     * @param callback the callback to remove (optional)
     * @param eventType the event type to remove (optional)
     * @param selector the selector from which to remove the event (optional)
     */
    EventManager.prototype.unregisterCallback = function (templateName, callback, eventType, selector) {
        var callbackDefs = this._callbacksContainer[templateName] || [];
        this._callbacksContainer[templateName] = callbackDefs.filter(function (callbackDef) { return (!callbackDef.eventType || callbackDef.eventType === eventType) && (!callbackDef.selector || callbackDef.selector === selector); });
    };
    EventManager.prototype._eventTriggered = function (data) {
        var templateName = data.template.name;
        var eventType = data.event.type;
        var selector = data.selector;
        var callbackDefs = this._callbacksContainer[templateName] || [];
        callbackDefs.filter(function (callbackDef) { return (!callbackDef.eventType || callbackDef.eventType === eventType) && (!callbackDef.selector || callbackDef.selector === selector); }).forEach(function (callbackDef) {
            callbackDef.callback(data);
        });
    };
    /**
     * Dispose the event manager
     */
    EventManager.prototype.dispose = function () {
        this._callbacksContainer = {};
    };
    return EventManager;
}());
export { EventManager };
//# sourceMappingURL=eventManager.js.map