import { AbstractMesh } from "@babylonjs/core/Meshes/abstractMesh";
import { Observable } from "@babylonjs/core/Misc/observable";
import { AnimationGroup } from "@babylonjs/core/Animations/animationGroup";
import { Animation, CircleEase, BackEase, BounceEase, CubicEase, ElasticEase, ExponentialEase, PowerEase, QuadraticEase, QuarticEase, QuinticEase, SineEase } from "@babylonjs/core/Animations/index";
import { Quaternion, Vector3 } from "@babylonjs/core/Maths/math.vector";
import { Tags } from "@babylonjs/core/Misc/tags";
import { PBRMaterial } from "@babylonjs/core/Materials/PBR/pbrMaterial";
import { MultiMaterial } from "@babylonjs/core/Materials/multiMaterial";
import { Tools } from "@babylonjs/core/Misc/tools";
import { GroupModelAnimation, AnimationPlayMode, EasingFunction, AnimationState } from "./modelAnimation";
import { deepmerge, extendClassWithConfig } from '../helper/';
/**
 * The current state of the model
 */
export var ModelState;
(function (ModelState) {
    ModelState[ModelState["INIT"] = 0] = "INIT";
    ModelState[ModelState["LOADING"] = 1] = "LOADING";
    ModelState[ModelState["LOADED"] = 2] = "LOADED";
    ModelState[ModelState["ENTRY"] = 3] = "ENTRY";
    ModelState[ModelState["ENTRYDONE"] = 4] = "ENTRYDONE";
    ModelState[ModelState["COMPLETE"] = 5] = "COMPLETE";
    ModelState[ModelState["CANCELED"] = 6] = "CANCELED";
    ModelState[ModelState["ERROR"] = 7] = "ERROR";
})(ModelState || (ModelState = {}));
/**
 * The viewer model is a container for all assets representing a sngle loaded model.
 */
var ViewerModel = /** @class */ (function () {
    function ViewerModel(_observablesManager, modelConfiguration, _configurationContainer) {
        var _this = this;
        this._observablesManager = _observablesManager;
        this._configurationContainer = _configurationContainer;
        /**
         * the list of meshes that are a part of this model
         */
        this._meshes = [];
        /**
         * ParticleSystems connected to this model
         */
        this.particleSystems = [];
        /**
         * Skeletons defined in this model
         */
        this.skeletons = [];
        this._loaderDone = false;
        this._animatables = [];
        this._frameRate = 60;
        this._shadowsRenderedAfterLoad = false;
        this.onLoadedObservable = new Observable();
        this.onLoadErrorObservable = new Observable();
        this.onLoadProgressObservable = new Observable();
        this.onCompleteObservable = new Observable();
        this.onAfterConfigure = new Observable();
        this.state = ModelState.INIT;
        var scene = this._configurationContainer && this._configurationContainer.scene;
        this.rootMesh = new AbstractMesh("modelRootMesh", scene);
        this._pivotMesh = new AbstractMesh("pivotMesh", scene);
        this._pivotMesh.parent = this.rootMesh;
        // rotate 180, gltf fun
        this._pivotMesh.rotation.y += Math.PI;
        this._scaleTransition = new Animation("scaleAnimation", "scaling", this._frameRate, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
        this._animations = [];
        //create a copy of the configuration to make sure it doesn't change even after it is changed in the viewer
        this._modelConfiguration = deepmerge((this._configurationContainer && this._configurationContainer.configuration.model) || {}, modelConfiguration);
        if (this._observablesManager) {
            this._observablesManager.onModelAddedObservable.notifyObservers(this);
        }
        if (this._modelConfiguration.entryAnimation) {
            this.rootMesh.setEnabled(false);
        }
        this.onLoadedObservable.add(function () {
            _this.updateConfiguration(_this._modelConfiguration);
            if (_this._observablesManager) {
                _this._observablesManager.onModelLoadedObservable.notifyObservers(_this);
            }
            _this._initAnimations();
        });
        this.onCompleteObservable.add(function () {
            _this.state = ModelState.COMPLETE;
        });
    }
    Object.defineProperty(ViewerModel.prototype, "shadowsRenderedAfterLoad", {
        get: function () {
            return this._shadowsRenderedAfterLoad;
        },
        set: function (rendered) {
            if (!rendered) {
                throw new Error("can only be enabled");
            }
            else {
                this._shadowsRenderedAfterLoad = rendered;
            }
        },
        enumerable: true,
        configurable: true
    });
    ViewerModel.prototype.getViewerId = function () {
        return this._configurationContainer && this._configurationContainer.viewerId;
    };
    Object.defineProperty(ViewerModel.prototype, "enabled", {
        /**
         * Is this model enabled?
         */
        get: function () {
            return this.rootMesh.isEnabled();
        },
        /**
         * Set whether this model is enabled or not.
         */
        set: function (enable) {
            this.rootMesh.setEnabled(enable);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewerModel.prototype, "loaderDone", {
        set: function (done) {
            this._loaderDone = done;
            this._checkCompleteState();
        },
        enumerable: true,
        configurable: true
    });
    ViewerModel.prototype._checkCompleteState = function () {
        if (this._loaderDone && (this.state === ModelState.ENTRYDONE)) {
            this._modelComplete();
        }
    };
    /**
     * Add a mesh to this model.
     * Any mesh that has no parent will be provided with the root mesh as its new parent.
     *
     * @param mesh the new mesh to add
     * @param triggerLoaded should this mesh trigger the onLoaded observable. Used when adding meshes manually.
     */
    ViewerModel.prototype.addMesh = function (mesh, triggerLoaded) {
        if (!mesh.parent) {
            mesh.parent = this._pivotMesh;
        }
        if (mesh.getClassName() !== "InstancedMesh") {
            mesh.receiveShadows = !!this.configuration.receiveShadows;
        }
        this._meshes.push(mesh);
        if (triggerLoaded) {
            return this.onLoadedObservable.notifyObserversWithPromise(this);
        }
    };
    Object.defineProperty(ViewerModel.prototype, "meshes", {
        /**
         * get the list of meshes (excluding the root mesh)
         */
        get: function () {
            return this._meshes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewerModel.prototype, "configuration", {
        /**
         * Get the model's configuration
         */
        get: function () {
            return this._modelConfiguration;
        },
        /**
         * (Re-)set the model's entire configuration
         * @param newConfiguration the new configuration to replace the new one
         */
        set: function (newConfiguration) {
            this._modelConfiguration = newConfiguration;
            this._configureModel();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Update the current configuration with new values.
     * Configuration will not be overwritten, but merged with the new configuration.
     * Priority is to the new configuration
     * @param newConfiguration the configuration to be merged into the current configuration;
     */
    ViewerModel.prototype.updateConfiguration = function (newConfiguration) {
        this._modelConfiguration = deepmerge(this._modelConfiguration, newConfiguration);
        this._configureModel();
    };
    ViewerModel.prototype._initAnimations = function () {
        var _this = this;
        // check if this is not a gltf loader and init the animations
        if (this.skeletons.length) {
            this.skeletons.forEach(function (skeleton, idx) {
                var ag = new AnimationGroup("animation-" + idx, _this._configurationContainer && _this._configurationContainer.scene);
                var add = false;
                skeleton.getAnimatables().forEach(function (a) {
                    if (a.animations && a.animations[0]) {
                        ag.addTargetedAnimation(a.animations[0], a);
                        add = true;
                    }
                });
                if (add) {
                    _this.addAnimationGroup(ag);
                }
            });
        }
        var completeCallback = function () {
        };
        if (this._modelConfiguration.animation) {
            if (this._modelConfiguration.animation.playOnce) {
                this._animations.forEach(function (a) {
                    a.playMode = AnimationPlayMode.ONCE;
                });
            }
            if (this._modelConfiguration.animation.autoStart && this._animations.length) {
                var animationName_1 = this._modelConfiguration.animation.autoStart === true ?
                    this._animations[0].name : this._modelConfiguration.animation.autoStart;
                completeCallback = function () {
                    _this.playAnimation(animationName_1);
                };
            }
        }
        this._enterScene(completeCallback);
    };
    /**
     * Animates the model from the current position to the default position
     * @param completeCallback A function to call when the animation has completed
     */
    ViewerModel.prototype._enterScene = function (completeCallback) {
        var _this = this;
        var scene = this.rootMesh.getScene();
        var previousValue = scene.animationPropertiesOverride.enableBlending;
        var callback = function () {
            _this.state = ModelState.ENTRYDONE;
            scene.animationPropertiesOverride.enableBlending = previousValue;
            _this._checkCompleteState();
            if (completeCallback) {
                completeCallback();
            }
        };
        if (!this._entryAnimation) {
            callback();
            return;
        }
        this.rootMesh.setEnabled(true);
        // disable blending for the sake of the entry animation;
        scene.animationPropertiesOverride.enableBlending = false;
        this._applyAnimation(this._entryAnimation, true, callback);
    };
    /**
     * Animates the model from the current position to the exit-screen position
     * @param completeCallback A function to call when the animation has completed
     */
    ViewerModel.prototype._exitScene = function (completeCallback) {
        if (!this._exitAnimation) {
            completeCallback();
            return;
        }
        this._applyAnimation(this._exitAnimation, false, completeCallback);
    };
    ViewerModel.prototype._modelComplete = function () {
        var _this = this;
        //reapply material defines to be sure:
        var meshes = this._pivotMesh.getChildMeshes(false);
        meshes.filter(function (m) { return m.material; }).forEach(function (mesh) {
            _this._applyModelMaterialConfiguration(mesh.material);
        });
        this.state = ModelState.COMPLETE;
        this.onCompleteObservable.notifyObservers(this);
    };
    /**
     * Add a new animation group to this model.
     * @param animationGroup the new animation group to be added
     */
    ViewerModel.prototype.addAnimationGroup = function (animationGroup) {
        this._animations.push(new GroupModelAnimation(animationGroup));
    };
    /**
     * Get the ModelAnimation array
     */
    ViewerModel.prototype.getAnimations = function () {
        return this._animations;
    };
    /**
     * Get the animations' names. Using the names you can play a specific animation.
     */
    ViewerModel.prototype.getAnimationNames = function () {
        return this._animations.map(function (a) { return a.name; });
    };
    /**
     * Get an animation by the provided name. Used mainly when playing n animation.
     * @param name the name of the animation to find
     */
    ViewerModel.prototype._getAnimationByName = function (name) {
        // can't use .find, noe available on IE
        var filtered = this._animations.filter(function (a) { return a.name === name.trim(); });
        // what the next line means - if two animations have the same name, they will not be returned!
        if (filtered.length === 1) {
            return filtered[0];
        }
        else {
            return null;
        }
    };
    /**
     * Choose an initialized animation using its name and start playing it
     * @param name the name of the animation to play
     * @returns The model aniamtion to be played.
     */
    ViewerModel.prototype.playAnimation = function (name) {
        var animation = this.setCurrentAnimationByName(name);
        if (animation) {
            animation.start();
        }
        return animation;
    };
    ViewerModel.prototype.setCurrentAnimationByName = function (name) {
        var animation = this._getAnimationByName(name.trim());
        if (animation) {
            if (this.currentAnimation && this.currentAnimation.state !== AnimationState.STOPPED) {
                this.currentAnimation.stop();
            }
            this.currentAnimation = animation;
            return animation;
        }
        else {
            throw new Error("animation not found - " + name);
        }
    };
    ViewerModel.prototype._configureModel = function () {
        var _this = this;
        // this can be changed to the meshes that have rootMesh a parent without breaking anything.
        var meshesWithNoParent = [this.rootMesh]; //this._meshes.filter(m => m.parent === this.rootMesh);
        var updateMeshesWithNoParent = function (variable, value, param) {
            meshesWithNoParent.forEach(function (mesh) {
                if (param) {
                    mesh[variable][param] = value;
                }
                else {
                    mesh[variable] = value;
                }
            });
        };
        var updateXYZ = function (variable, configValues) {
            if (configValues.x !== undefined) {
                updateMeshesWithNoParent(variable, configValues.x, 'x');
            }
            if (configValues.y !== undefined) {
                updateMeshesWithNoParent(variable, configValues.y, 'y');
            }
            if (configValues.z !== undefined) {
                updateMeshesWithNoParent(variable, configValues.z, 'z');
            }
            if (configValues.w !== undefined) {
                updateMeshesWithNoParent(variable, configValues.w, 'w');
            }
        };
        if (this._modelConfiguration.normalize) {
            var center = false;
            var unitSize = false;
            var parentIndex = void 0;
            if (this._modelConfiguration.normalize === true) {
                center = true;
                unitSize = true;
            }
            else {
                center = !!this._modelConfiguration.normalize.center;
                unitSize = !!this._modelConfiguration.normalize.unitSize;
                parentIndex = this._modelConfiguration.normalize.parentIndex;
            }
            var meshesToNormalize = [];
            if (parentIndex !== undefined) {
                meshesToNormalize.push(this._meshes[parentIndex]);
            }
            else {
                meshesToNormalize = this._pivotMesh.getChildMeshes(true).length === 1 ? [this._pivotMesh] : meshesWithNoParent;
            }
            if (unitSize) {
                meshesToNormalize.forEach(function (mesh) {
                    mesh.normalizeToUnitCube(true);
                    mesh.computeWorldMatrix(true);
                });
            }
            if (center) {
                meshesToNormalize.forEach(function (mesh) {
                    var boundingInfo = mesh.getHierarchyBoundingVectors(true);
                    var sizeVec = boundingInfo.max.subtract(boundingInfo.min);
                    var halfSizeVec = sizeVec.scale(0.5);
                    var center = boundingInfo.min.add(halfSizeVec);
                    mesh.position = center.scale(-1);
                    mesh.position.y += halfSizeVec.y;
                    // Recompute Info.
                    mesh.computeWorldMatrix(true);
                });
            }
        }
        else {
            // if centered, should be done here
        }
        // position?
        if (this._modelConfiguration.position) {
            updateXYZ('position', this._modelConfiguration.position);
        }
        if (this._modelConfiguration.rotation) {
            //quaternion?
            if (this._modelConfiguration.rotation.w) {
                meshesWithNoParent.forEach(function (mesh) {
                    if (!mesh.rotationQuaternion) {
                        mesh.rotationQuaternion = new Quaternion();
                    }
                });
                updateXYZ('rotationQuaternion', this._modelConfiguration.rotation);
            }
            else {
                updateXYZ('rotation', this._modelConfiguration.rotation);
            }
        }
        if (this._modelConfiguration.rotationOffsetAxis) {
            var rotationAxis_1 = new Vector3(0, 0, 0).copyFrom(this._modelConfiguration.rotationOffsetAxis);
            meshesWithNoParent.forEach(function (m) {
                if (_this._modelConfiguration.rotationOffsetAngle) {
                    m.rotate(rotationAxis_1, _this._modelConfiguration.rotationOffsetAngle);
                }
            });
        }
        if (this._modelConfiguration.scaling) {
            updateXYZ('scaling', this._modelConfiguration.scaling);
        }
        if (this._modelConfiguration.castShadow) {
            this._meshes.forEach(function (mesh) {
                Tags.AddTagsTo(mesh, 'castShadow');
            });
        }
        var meshes = this._pivotMesh.getChildMeshes(false);
        meshes.filter(function (m) { return m.material; }).forEach(function (mesh) {
            _this._applyModelMaterialConfiguration(mesh.material);
        });
        if (this._modelConfiguration.entryAnimation) {
            this._entryAnimation = this._modelAnimationConfigurationToObject(this._modelConfiguration.entryAnimation);
        }
        if (this._modelConfiguration.exitAnimation) {
            this._exitAnimation = this._modelAnimationConfigurationToObject(this._modelConfiguration.exitAnimation);
        }
        this.onAfterConfigure.notifyObservers(this);
    };
    ViewerModel.prototype._modelAnimationConfigurationToObject = function (animConfig) {
        var anim = {
            time: 0.5
        };
        if (animConfig.scaling) {
            anim.scaling = Vector3.Zero();
        }
        if (animConfig.easingFunction !== undefined) {
            anim.easingFunction = animConfig.easingFunction;
        }
        if (animConfig.easingMode !== undefined) {
            anim.easingMode = animConfig.easingMode;
        }
        extendClassWithConfig(anim, animConfig);
        return anim;
    };
    /**
     * Apply a material configuration to a material
     * @param material Material to apply configuration to
     * @hidden
     */
    ViewerModel.prototype._applyModelMaterialConfiguration = function (material) {
        if (!this._modelConfiguration.material) {
            return;
        }
        extendClassWithConfig(material, this._modelConfiguration.material);
        if (material instanceof PBRMaterial) {
            if (this._modelConfiguration.material.directIntensity !== undefined) {
                material.directIntensity = this._modelConfiguration.material.directIntensity;
            }
            if (this._modelConfiguration.material.emissiveIntensity !== undefined) {
                material.emissiveIntensity = this._modelConfiguration.material.emissiveIntensity;
            }
            if (this._modelConfiguration.material.environmentIntensity !== undefined) {
                material.environmentIntensity = this._modelConfiguration.material.environmentIntensity;
            }
            if (this._modelConfiguration.material.directEnabled !== undefined) {
                material.disableLighting = !this._modelConfiguration.material.directEnabled;
            }
            if (this._configurationContainer && this._configurationContainer.reflectionColor) {
                material.reflectionColor = this._configurationContainer.reflectionColor.clone();
            }
        }
        else if (material instanceof MultiMaterial) {
            for (var i = 0; i < material.subMaterials.length; i++) {
                var subMaterial = material.subMaterials[i];
                if (subMaterial) {
                    this._applyModelMaterialConfiguration(subMaterial);
                }
            }
        }
    };
    /**
     * Start entry/exit animation given an animation configuration
     * @param animationConfiguration Entry/Exit animation configuration
     * @param isEntry Pass true if the animation is an entry animation
     * @param completeCallback Callback to execute when the animation completes
     */
    ViewerModel.prototype._applyAnimation = function (animationConfiguration, isEntry, completeCallback) {
        var animations = [];
        //scale
        if (animationConfiguration.scaling) {
            var scaleStart = isEntry ? animationConfiguration.scaling : new Vector3(1, 1, 1);
            var scaleEnd = isEntry ? new Vector3(1, 1, 1) : animationConfiguration.scaling;
            if (!scaleStart.equals(scaleEnd)) {
                this.rootMesh.scaling = scaleStart;
                this._setLinearKeys(this._scaleTransition, this.rootMesh.scaling, scaleEnd, animationConfiguration.time);
                animations.push(this._scaleTransition);
            }
        }
        //Start the animation(s)
        this.transitionTo(animations, animationConfiguration.time, this._createEasingFunction(animationConfiguration.easingFunction), animationConfiguration.easingMode, function () { if (completeCallback) {
            completeCallback();
        } });
    };
    /**
    * Begin @animations with the specified @easingFunction
    * @param animations The BABYLON Animations to begin
    * @param duration of transition, in seconds
    * @param easingFunction An easing function to apply
    * @param easingMode A easing mode to apply to the easingFunction
    * @param onAnimationEnd Call back trigger at the end of the animation.
    */
    ViewerModel.prototype.transitionTo = function (animations, duration, easingFunction, easingMode, // BABYLON.EasingFunction.EASINGMODE_EASEINOUT,
    onAnimationEnd) {
        if (easingMode === void 0) { easingMode = 2; }
        if (easingFunction) {
            for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
                var animation = animations_1[_i];
                easingFunction.setEasingMode(easingMode);
                animation.setEasingFunction(easingFunction);
            }
        }
        //Stop any current animations before starting the new one - merging not yet supported.
        this.stopAllAnimations();
        this.rootMesh.animations = animations;
        if (this.rootMesh.getScene().beginAnimation) {
            var animatable = this.rootMesh.getScene().beginAnimation(this.rootMesh, 0, this._frameRate * duration, false, 1, function () {
                if (onAnimationEnd) {
                    onAnimationEnd();
                }
            });
            this._animatables.push(animatable);
        }
    };
    /**
     * Sets key values on an Animation from first to last frame.
     * @param animation The Babylon animation object to set keys on
     * @param startValue The value of the first key
     * @param endValue The value of the last key
     * @param duration The duration of the animation, used to determine the end frame
     */
    ViewerModel.prototype._setLinearKeys = function (animation, startValue, endValue, duration) {
        animation.setKeys([
            {
                frame: 0,
                value: startValue
            },
            {
                frame: this._frameRate * duration,
                value: endValue
            }
        ]);
    };
    /**
     * Creates and returns a Babylon easing funtion object based on a string representing the Easing function
     * @param easingFunctionID The enum of the easing funtion to create
     * @return The newly created Babylon easing function object
     */
    ViewerModel.prototype._createEasingFunction = function (easingFunctionID) {
        var easingFunction;
        switch (easingFunctionID) {
            case EasingFunction.CircleEase:
                easingFunction = new CircleEase();
                break;
            case EasingFunction.BackEase:
                easingFunction = new BackEase(0.3);
                break;
            case EasingFunction.BounceEase:
                easingFunction = new BounceEase();
                break;
            case EasingFunction.CubicEase:
                easingFunction = new CubicEase();
                break;
            case EasingFunction.ElasticEase:
                easingFunction = new ElasticEase();
                break;
            case EasingFunction.ExponentialEase:
                easingFunction = new ExponentialEase();
                break;
            case EasingFunction.PowerEase:
                easingFunction = new PowerEase();
                break;
            case EasingFunction.QuadraticEase:
                easingFunction = new QuadraticEase();
                break;
            case EasingFunction.QuarticEase:
                easingFunction = new QuarticEase();
                break;
            case EasingFunction.QuinticEase:
                easingFunction = new QuinticEase();
                break;
            case EasingFunction.SineEase:
                easingFunction = new SineEase();
                break;
            default:
                Tools.Log("No ease function found");
                break;
        }
        return easingFunction;
    };
    /**
     * Stops and removes all animations that have been applied to the model
     */
    ViewerModel.prototype.stopAllAnimations = function () {
        if (this.rootMesh) {
            this.rootMesh.animations = [];
        }
        if (this.currentAnimation) {
            this.currentAnimation.stop();
        }
        while (this._animatables.length) {
            this._animatables[0].onAnimationEnd = null;
            this._animatables[0].stop();
            this._animatables.shift();
        }
    };
    /**
     * Will remove this model from the viewer (but NOT dispose it).
     */
    ViewerModel.prototype.remove = function () {
        this.stopAllAnimations();
        // hide it
        this.rootMesh.isVisible = false;
        if (this._observablesManager) {
            this._observablesManager.onModelRemovedObservable.notifyObservers(this);
        }
    };
    /**
     * Dispose this model, including all of its associated assets.
     */
    ViewerModel.prototype.dispose = function () {
        this.remove();
        this.onAfterConfigure.clear();
        this.onLoadedObservable.clear();
        this.onLoadErrorObservable.clear();
        this.onLoadProgressObservable.clear();
        if (this.loader && this.loader.name === "gltf") {
            this.loader.dispose();
        }
        this.particleSystems.forEach(function (ps) { return ps.dispose(); });
        this.particleSystems.length = 0;
        this.skeletons.forEach(function (s) { return s.dispose(); });
        this.skeletons.length = 0;
        this._animations.forEach(function (ag) { return ag.dispose(); });
        this._animations.length = 0;
        this.rootMesh.dispose(false, true);
    };
    return ViewerModel;
}());
export { ViewerModel };
//# sourceMappingURL=viewerModel.js.map