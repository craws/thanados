import { getConfigurationKey } from '../configuration';
import { ModelState } from '../model/viewerModel';
import { extendClassWithConfig } from '../helper';
import { ViewerLabs } from '../labs/viewerLabs';
import { getCustomOptimizerByName } from '../optimizer/custom/';
import { deepmerge } from '../helper';
import { Observable } from '@babylonjs/core/Misc/observable';
import { SceneOptimizer, SceneOptimizerOptions } from '@babylonjs/core/Misc/sceneOptimizer';
import { ArcRotateCamera } from '@babylonjs/core/Cameras/arcRotateCamera';
import { Light } from '@babylonjs/core/Lights/light';
import { EnvironmentHelper } from '@babylonjs/core/Helpers/environmentHelper';
import { Color3, Quaternion, Vector3, Axis, Matrix } from '@babylonjs/core/Maths/math';
import { DefaultRenderingPipeline } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline';
import { Animation } from '@babylonjs/core/Animations/index';
import { AnimationPropertiesOverride } from '@babylonjs/core/Animations/animationPropertiesOverride';
import { RenderTargetTexture } from '@babylonjs/core/Materials/Textures/renderTargetTexture';
import { PBRMaterial } from '@babylonjs/core/Materials/PBR/pbrMaterial';
import { ShadowLight } from '@babylonjs/core/Lights/shadowLight';
import { CubeTexture } from '@babylonjs/core/Materials/Textures/cubeTexture';
import { HemisphericLight } from '@babylonjs/core/Lights/hemisphericLight';
import { Scalar } from '@babylonjs/core/Maths/math.scalar';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { Tags } from '@babylonjs/core/Misc/tags';
import { Scene } from '@babylonjs/core/scene';
import { ShadowGenerator } from '@babylonjs/core/Lights/Shadows/shadowGenerator';
import { Constants } from '@babylonjs/core/Engines/constants';
var SceneManager = /** @class */ (function () {
    function SceneManager(_engine, _configurationContainer, _observablesManager) {
        var _this = this;
        this._engine = _engine;
        this._configurationContainer = _configurationContainer;
        this._observablesManager = _observablesManager;
        this._animationBlendingEnabled = true;
        this._white = Color3.White();
        this._forceShadowUpdate = false;
        this._processShadows = true;
        this._groundEnabled = true;
        this._groundMirrorEnabled = true;
        this._defaultRenderingPipelineEnabled = false;
        this._globalConfiguration = {};
        this._defaultRenderingPipelineShouldBuild = true;
        // default from rendering pipeline
        this._bloomEnabled = false;
        // default from rendering pipeline
        this._fxaaEnabled = false;
        this._focusOnModel = function (model) {
            var boundingInfo = model.rootMesh.getHierarchyBoundingVectors(true);
            var sizeVec = boundingInfo.max.subtract(boundingInfo.min);
            var halfSizeVec = sizeVec.scale(0.5);
            var center = boundingInfo.min.add(halfSizeVec);
            _this.camera.setTarget(center);
            _this.camera.alpha = (_this._globalConfiguration.camera && _this._globalConfiguration.camera.alpha) || _this.camera.alpha;
            _this.camera.beta = (_this._globalConfiguration.camera && _this._globalConfiguration.camera.beta) || _this.camera.beta;
            _this.camera.radius = (_this._globalConfiguration.camera && _this._globalConfiguration.camera.radius) || _this.camera.radius;
            var sceneDiagonalLenght = sizeVec.length();
            if (isFinite(sceneDiagonalLenght)) {
                _this.camera.upperRadiusLimit = sceneDiagonalLenght * 4;
            }
            if (_this._configurationContainer.configuration) {
                _this._configureEnvironment(_this._configurationContainer.configuration.skybox, _this._configurationContainer.configuration.ground);
            }
            /*this.scene.lights.filter(light => light instanceof ShadowLight).forEach(light => {
                // casting ais safe, due to the constraints tested before
                (<ShadowLight>light).setDirectionToTarget(center);
            });*/
        };
        this._cameraBehaviorMapping = {};
        this.models = [];
        this.onCameraConfiguredObservable = new Observable();
        this.onLightsConfiguredObservable = new Observable();
        this.onModelsConfiguredObservable = new Observable();
        this.onSceneConfiguredObservable = new Observable();
        this.onSceneInitObservable = new Observable();
        this.onSceneOptimizerConfiguredObservable = new Observable();
        this.onEnvironmentConfiguredObservable = new Observable();
        this.onVRConfiguredObservable = new Observable();
        //this._viewer.onEngineInitObservable.add(() => {
        this._handleHardwareLimitations();
        //});
        this.onSceneInitObservable.add(function (scene) {
            _this.scene.animationPropertiesOverride = _this.scene.animationPropertiesOverride || new AnimationPropertiesOverride();
            _this.labs = new ViewerLabs(scene);
            var updateShadows = function () {
                for (var _i = 0, _a = _this.scene.lights; _i < _a.length; _i++) {
                    var light = _a[_i];
                    var generator = light.getShadowGenerator();
                    if (generator) {
                        // Processing shadows if animates
                        var shadowMap = generator.getShadowMap();
                        if (shadowMap) {
                            shadowMap.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
                        }
                    }
                }
            };
            scene.registerBeforeRender(function () {
                if (_this._forceShadowUpdate || (scene.animatables && scene.animatables.length > 0)) {
                    // make sure all models are loaded
                    updateShadows();
                    _this._forceShadowUpdate = false;
                }
                else if (!(_this.models.every(function (model) {
                    if (!model.shadowsRenderedAfterLoad) {
                        model.shadowsRenderedAfterLoad = true;
                        return false;
                    }
                    return model.state === ModelState.COMPLETE && !model.currentAnimation;
                }))) {
                    updateShadows();
                }
            });
            return _this._observablesManager && _this._observablesManager.onSceneInitObservable.notifyObserversWithPromise(_this.scene);
        });
        if (this._observablesManager) {
            this._observablesManager.onModelLoadedObservable.add(function (model) {
                for (var _i = 0, _a = _this.scene.lights; _i < _a.length; _i++) {
                    var light = _a[_i];
                    var generator = light.getShadowGenerator();
                    if (generator) {
                        // Processing shadows if animates
                        var shadowMap = generator.getShadowMap();
                        if (shadowMap) {
                            shadowMap.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
                        }
                    }
                }
                _this._focusOnModel(model);
            });
            this._observablesManager.onModelAddedObservable.add(function (model) {
                _this.models.push(model);
            });
            this._observablesManager.onModelRemovedObservable.add(function (model) {
                _this.models.splice(_this.models.indexOf(model), 1);
            });
        }
    }
    Object.defineProperty(SceneManager.prototype, "defaultRenderingPipeline", {
        get: function () {
            return this._defaultRenderingPipeline;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "vrHelper", {
        get: function () {
            return this._vrHelper;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "isHdrSupported", {
        /**
         * Returns a boolean representing HDR support
         */
        get: function () {
            return this._hdrSupport;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "mainColor", {
        /**
         * Return the main color defined in the configuration.
         */
        get: function () {
            return this._configurationContainer.mainColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "reflectionColor", {
        get: function () {
            return this._configurationContainer.reflectionColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "animationBlendingEnabled", {
        get: function () {
            return this.scene && this.scene.animationPropertiesOverride.enableBlending;
        },
        set: function (value) {
            this.scene.animationPropertiesOverride.enableBlending = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "observablesManager", {
        get: function () {
            return this._observablesManager;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "processShadows", {
        /**
         * The flag defining whether shadows are rendered constantly or once.
         */
        get: function () {
            return this._processShadows;
        },
        /**
         * Should shadows be rendered every frame, or only once and stop.
         * This can be used to optimize a scene.
         *
         * Not that the shadows will NOT disapear but will remain in place.
         * @param process if true shadows will be updated once every frame. if false they will stop being updated.
         */
        set: function (process) {
            var refreshType = process ? RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME : RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
            for (var _i = 0, _a = this.scene.lights; _i < _a.length; _i++) {
                var light = _a[_i];
                var generator = light.getShadowGenerator();
                if (generator) {
                    var shadowMap = generator.getShadowMap();
                    if (shadowMap) {
                        shadowMap.refreshRate = refreshType;
                    }
                }
            }
            this._processShadows = process;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "groundEnabled", {
        get: function () {
            return this._groundEnabled;
        },
        set: function (newValue) {
            if (newValue === this._groundEnabled) {
                return;
            }
            this._groundEnabled = newValue;
            if (this.environmentHelper && this.environmentHelper.ground) {
                this.environmentHelper.ground.setEnabled(this._groundEnabled);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "groundMirrorEnabled", {
        /**
         * gets wether the reflection is disabled.
         */
        get: function () {
            return this._groundMirrorEnabled;
        },
        /**
         * sets wether the reflection is disabled.
         */
        set: function (value) {
            if (this._groundMirrorEnabled === value) {
                return;
            }
            this._groundMirrorEnabled = value;
            if (this.environmentHelper && this.environmentHelper.groundMaterial && this.environmentHelper.groundMirror) {
                if (!value) {
                    this.environmentHelper.groundMaterial.reflectionTexture = null;
                }
                else {
                    this.environmentHelper.groundMaterial.reflectionTexture = this.environmentHelper.groundMirror;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "defaultRenderingPipelineEnabled", {
        get: function () {
            return this._defaultRenderingPipelineEnabled;
        },
        set: function (value) {
            if (value === this._defaultRenderingPipelineEnabled) {
                return;
            }
            this._defaultRenderingPipelineEnabled = value;
            this._rebuildPostprocesses();
            if (this._defaultRenderingPipeline) {
                this._defaultRenderingPipelineShouldBuild = false;
                this._defaultRenderingPipeline.prepare();
                this.scene.imageProcessingConfiguration.applyByPostProcess = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the engine flags to unlock all babylon features.
     * Can also be configured using the scene.flags configuration object
     */
    SceneManager.prototype.unlockBabylonFeatures = function () {
        this.scene.shadowsEnabled = true;
        this.scene.particlesEnabled = true;
        this.scene.postProcessesEnabled = true;
        this.scene.collisionsEnabled = true;
        this.scene.lightsEnabled = true;
        this.scene.texturesEnabled = true;
        this.scene.lensFlaresEnabled = true;
        this.scene.proceduralTexturesEnabled = true;
        this.scene.renderTargetsEnabled = true;
        this.scene.spritesEnabled = true;
        this.scene.skeletonsEnabled = true;
        this.scene.audioEnabled = true;
    };
    /**
     * initialize the scene. Calling this function again will dispose the old scene, if exists.
     */
    SceneManager.prototype.initScene = function (sceneConfiguration, optimizerConfiguration) {
        if (sceneConfiguration === void 0) { sceneConfiguration = {}; }
        // if the scen exists, dispose it.
        if (this.scene) {
            this.scene.dispose();
        }
        // create a new scene
        this.scene = new Scene(this._engine);
        this._configurationContainer.scene = this.scene;
        // set a default PBR material
        if (!sceneConfiguration.defaultMaterial) {
            var defaultMaterial = new PBRMaterial('defaultMaterial', this.scene);
            defaultMaterial.reflectivityColor = new Color3(0.1, 0.1, 0.1);
            defaultMaterial.microSurface = 0.6;
            if (this.scene.defaultMaterial) {
                this.scene.defaultMaterial.dispose();
            }
            this.scene.defaultMaterial = defaultMaterial;
        }
        this.scene.animationPropertiesOverride = new AnimationPropertiesOverride();
        Animation.AllowMatricesInterpolation = true;
        /*if (sceneConfiguration.glow) {
            let options: Partial<IGlowLayerOptions> = {
                mainTextureFixedSize: 512
            };
            if (typeof sceneConfiguration.glow === 'object') {
                options = sceneConfiguration.glow
            }
            var gl = new GlowLayer("glow", this.scene, options);
        }*/
        return this.onSceneInitObservable.notifyObserversWithPromise(this.scene);
    };
    SceneManager.prototype.clearScene = function (clearModels, clearLights) {
        if (clearModels === void 0) { clearModels = true; }
        if (clearLights === void 0) { clearLights = false; }
        if (clearModels) {
            this.models.forEach(function (m) { return m.dispose(); });
            this.models.length = 0;
        }
        if (clearLights) {
            this.scene.lights.forEach(function (l) { return l.dispose(); });
        }
    };
    /**
     * This will update the scene's configuration, including camera, lights, environment.
     * @param newConfiguration the delta that should be configured. This includes only the changes
     * @param globalConfiguration The global configuration object, after the new configuration was merged into it
     */
    SceneManager.prototype.updateConfiguration = function (newConfiguration) {
        var _this = this;
        if (this._configurationContainer) {
            this._globalConfiguration = this._configurationContainer.configuration;
        }
        else {
            this._globalConfiguration = newConfiguration;
        }
        // update scene configuration
        if (newConfiguration.scene) {
            this._configureScene(newConfiguration.scene);
        }
        // optimizer
        if (newConfiguration.optimizer !== undefined) {
            this._configureOptimizer(newConfiguration.optimizer);
        }
        // configure model
        /*if (newConfiguration.model && typeof newConfiguration.model === 'object') {
            this._configureModel(newConfiguration.model);
        }*/
        // lights
        this._configureLights(newConfiguration.lights);
        // environment
        if (newConfiguration.skybox !== undefined || newConfiguration.ground !== undefined) {
            this._configureEnvironment(newConfiguration.skybox, newConfiguration.ground);
        }
        // camera
        this._configureCamera(newConfiguration.camera);
        if (newConfiguration.environmentMap !== undefined) {
            this._configureEnvironmentMap(newConfiguration.environmentMap);
        }
        if (newConfiguration.vr !== undefined) {
            this._configureVR(newConfiguration.vr);
        }
        if (newConfiguration.lab) {
            // rendering piplines
            if (newConfiguration.lab.defaultRenderingPipelines) {
                var pipelineConfig = newConfiguration.lab.defaultRenderingPipelines;
                if (typeof pipelineConfig === 'boolean') {
                    this.defaultRenderingPipelineEnabled = pipelineConfig;
                }
                else {
                    this.defaultRenderingPipelineEnabled = true;
                }
            }
            if (this.environmentHelper && newConfiguration.lab.environmentMainColor) {
                var mainColor = new Color3().copyFrom(newConfiguration.lab.environmentMainColor);
                this.environmentHelper.setMainColor(mainColor);
            }
            if (newConfiguration.lab.globalLightRotation !== undefined) {
                // rotate all lights that are shadow lights
                this.scene.lights.filter(function (light) { return light instanceof ShadowLight; }).forEach(function (light) {
                    // casting and '!' are safe, due to the constraints tested before
                    _this.labs.rotateShadowLight(light, newConfiguration.lab.globalLightRotation);
                });
                this._forceShadowUpdate = true;
            }
        }
        if (this._defaultRenderingPipeline && this._defaultRenderingPipeline.imageProcessing) {
            this._defaultRenderingPipeline.imageProcessing.fromLinearSpace = true;
        }
        if (this._defaultRenderingPipelineShouldBuild && this._defaultRenderingPipeline) {
            this._defaultRenderingPipelineShouldBuild = false;
            this._defaultRenderingPipeline.prepare();
        }
    };
    SceneManager.prototype._rebuildPostprocesses = function (configuration) {
        if (!this._defaultRenderingPipelineEnabled || !getConfigurationKey("scene.imageProcessingConfiguration.isEnabled", this._globalConfiguration)) {
            if (this._defaultRenderingPipeline) {
                this._defaultRenderingPipeline.dispose();
                this._defaultRenderingPipeline = null;
                this.scene.autoClearDepthAndStencil = true;
                this.scene.autoClear = true;
                this.scene.imageProcessingConfiguration.applyByPostProcess = false;
            }
            return;
        }
        var pipelineConfig = configuration || (this._globalConfiguration.lab && this._globalConfiguration.lab.defaultRenderingPipelines);
        if (pipelineConfig) {
            if (!this._defaultRenderingPipeline) {
                // Create pipeline in manual mode to avoid triggering multiple shader compilations
                this._defaultRenderingPipeline = new DefaultRenderingPipeline("default rendering pipeline", this._hdrSupport, this.scene, [this.camera], false);
            }
            this.scene.autoClear = false;
            this.scene.autoClearDepthAndStencil = false;
            this._defaultRenderingPipelineShouldBuild = true;
            var bloomEnabled = this._bloomEnabled;
            if (typeof pipelineConfig !== 'boolean') {
                extendClassWithConfig(this._defaultRenderingPipeline, pipelineConfig);
                this._bloomEnabled = !!pipelineConfig.bloomEnabled;
                this._fxaaEnabled = !!pipelineConfig.fxaaEnabled;
                bloomEnabled = this._bloomEnabled && pipelineConfig.bloomWeight !== undefined && pipelineConfig.bloomWeight > 0;
                this._defaultRenderingPipeline.bloomWeight = (pipelineConfig.bloomWeight !== undefined && pipelineConfig.bloomWeight) || (this._defaultRenderingPipeline.bloomWeight);
            }
            this._defaultRenderingPipeline.bloomEnabled = bloomEnabled;
            this._defaultRenderingPipeline.fxaaEnabled = this.fxaaEnabled;
        }
    };
    Object.defineProperty(SceneManager.prototype, "bloomEnabled", {
        get: function () {
            return this._bloomEnabled;
        },
        set: function (value) {
            if (this._bloomEnabled === value) {
                return;
            }
            this._bloomEnabled = value;
            this._rebuildPostprocesses();
            if (this._defaultRenderingPipeline) {
                this._defaultRenderingPipelineShouldBuild = false;
                this._defaultRenderingPipeline.prepare();
                this.scene.imageProcessingConfiguration.applyByPostProcess = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "fxaaEnabled", {
        get: function () {
            return this._fxaaEnabled;
        },
        set: function (value) {
            if (this._fxaaEnabled === value) {
                return;
            }
            this._fxaaEnabled = value;
            this._rebuildPostprocesses();
            if (this._defaultRenderingPipeline) {
                this._defaultRenderingPipelineShouldBuild = false;
                this._defaultRenderingPipeline.prepare();
                this.scene.imageProcessingConfiguration.applyByPostProcess = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    SceneManager.prototype.setDefaultMaterial = function (sceneConfig) {
    };
    /**
     * internally configure the scene using the provided configuration.
     * The scene will not be recreated, but just updated.
     * @param sceneConfig the (new) scene configuration
     */
    SceneManager.prototype._configureScene = function (sceneConfig) {
        // sanity check!
        if (!this.scene) {
            return;
        }
        var cc = sceneConfig.clearColor;
        var oldcc = this.scene.clearColor;
        if (cc) {
            if (cc.r !== undefined) {
                oldcc.r = cc.r;
            }
            if (cc.g !== undefined) {
                oldcc.g = cc.g;
            }
            if (cc.b !== undefined) {
                oldcc.b = cc.b;
            }
            if (cc.a !== undefined) {
                oldcc.a = cc.a;
            }
        }
        if (sceneConfig.assetsRootURL) {
            this._assetsRootURL = sceneConfig.assetsRootURL;
        }
        // image processing configuration - optional.
        if (sceneConfig.imageProcessingConfiguration) {
            extendClassWithConfig(this.scene.imageProcessingConfiguration, sceneConfig.imageProcessingConfiguration);
        }
        //animation properties override
        if (sceneConfig.animationPropertiesOverride) {
            extendClassWithConfig(this.scene.animationPropertiesOverride, sceneConfig.animationPropertiesOverride);
        }
        if (sceneConfig.environmentTexture) {
            if (!(this.scene.environmentTexture && this.scene.environmentTexture.url === sceneConfig.environmentTexture)) {
                if (this.scene.environmentTexture && this.scene.environmentTexture.dispose) {
                    this.scene.environmentTexture.dispose();
                }
                var environmentTexture = CubeTexture.CreateFromPrefilteredData(sceneConfig.environmentTexture, this.scene);
                this.scene.environmentTexture = environmentTexture;
            }
        }
        if (sceneConfig.debug === true) {
            this.scene.debugLayer.show();
        }
        else if (sceneConfig.debug === false) {
            if (this.scene.debugLayer.isVisible()) {
                this.scene.debugLayer.hide();
            }
        }
        if (sceneConfig.disableHdr) {
            this._handleHardwareLimitations(false);
        }
        else {
            this._handleHardwareLimitations(true);
        }
        if (sceneConfig.renderInBackground !== undefined) {
            this._engine.renderEvenInBackground = !!sceneConfig.renderInBackground;
        }
        var canvas = this._engine.getInputElement();
        if (canvas) {
            if (this.camera && sceneConfig.disableCameraControl) {
                this.camera.detachControl(canvas);
            }
            else if (this.camera && sceneConfig.disableCameraControl === false) {
                this.camera.attachControl(canvas);
            }
        }
        this.setDefaultMaterial(sceneConfig);
        if (sceneConfig.flags) {
            extendClassWithConfig(this.scene, sceneConfig.flags);
        }
        this.onSceneConfiguredObservable.notifyObservers({
            sceneManager: this,
            object: this.scene,
            newConfiguration: sceneConfig
        });
    };
    /**
     * Configure the scene optimizer.
     * The existing scene optimizer will be disposed and a new one will be created.
     * @param optimizerConfig the (new) optimizer configuration
     */
    SceneManager.prototype._configureOptimizer = function (optimizerConfig) {
        var _this = this;
        if (typeof optimizerConfig === 'boolean') {
            if (this.sceneOptimizer) {
                this.sceneOptimizer.stop();
                this.sceneOptimizer.dispose();
                delete this.sceneOptimizer;
            }
            if (optimizerConfig) {
                this.sceneOptimizer = new SceneOptimizer(this.scene);
                this.sceneOptimizer.start();
            }
        }
        else {
            var optimizerOptions = new SceneOptimizerOptions(optimizerConfig.targetFrameRate, optimizerConfig.trackerDuration);
            // check for degradation
            if (optimizerConfig.degradation) {
                switch (optimizerConfig.degradation) {
                    case "low":
                        optimizerOptions = SceneOptimizerOptions.LowDegradationAllowed(optimizerConfig.targetFrameRate);
                        break;
                    case "moderate":
                        optimizerOptions = SceneOptimizerOptions.ModerateDegradationAllowed(optimizerConfig.targetFrameRate);
                        break;
                    case "hight":
                        optimizerOptions = SceneOptimizerOptions.HighDegradationAllowed(optimizerConfig.targetFrameRate);
                        break;
                }
            }
            if (this.sceneOptimizer) {
                this.sceneOptimizer.stop();
                this.sceneOptimizer.dispose();
            }
            if (optimizerConfig.custom) {
                var customOptimizer_1 = getCustomOptimizerByName(optimizerConfig.custom, optimizerConfig.improvementMode);
                if (customOptimizer_1) {
                    optimizerOptions.addCustomOptimization(function () {
                        return customOptimizer_1(_this);
                    }, function () {
                        return "Babylon Viewer " + optimizerConfig.custom + " custom optimization";
                    });
                }
            }
            this.sceneOptimizer = new SceneOptimizer(this.scene, optimizerOptions, optimizerConfig.autoGeneratePriorities, optimizerConfig.improvementMode);
            this.sceneOptimizer.start();
        }
        this.onSceneOptimizerConfiguredObservable.notifyObservers({
            sceneManager: this,
            object: this.sceneOptimizer,
            newConfiguration: optimizerConfig
        });
    };
    /**
     * configure all models using the configuration.
     * @param modelConfiguration the configuration to use to reconfigure the models
     */
    /*protected _configureModel(modelConfiguration: Partial<IModelConfiguration>) {
        this.models.forEach(model => {
            model.updateConfiguration(modelConfiguration);
        });

        this.onModelsConfiguredObservable.notifyObservers({
            sceneManager: this,
            object: this.models,
            newConfiguration: modelConfiguration
        });
    }*/
    SceneManager.prototype._configureVR = function (vrConfig) {
        var _this = this;
        if (vrConfig.disabled) {
            if (this._vrHelper) {
                if (this._vrHelper.isInVRMode) {
                    this._vrHelper.exitVR();
                }
                this._vrHelper.dispose();
                this._vrHelper = undefined;
            }
            return;
        }
        var vrOptions = deepmerge({
            useCustomVRButton: true,
            createDeviceOrientationCamera: false,
            trackPosition: true
        }, vrConfig.vrOptions || {});
        this._vrHelper = this.scene.createDefaultVRExperience(vrOptions);
        if (!vrConfig.disableInteractions) {
            this._vrHelper.enableInteractions();
        }
        if (!vrConfig.disableTeleportation) {
            var floorMeshName = vrConfig.overrideFloorMeshName || "BackgroundPlane";
            this._vrHelper.enableTeleportation({
                floorMeshName: floorMeshName
            });
        }
        if (vrConfig.rotateUsingControllers) {
            var rotationOffset_1;
            this._vrHelper.onControllerMeshLoadedObservable.add(function (controller) {
                controller.onTriggerStateChangedObservable.add(function (data) {
                    if (controller.mesh && controller.mesh.rotationQuaternion) {
                        if (data.pressed) {
                            if (!rotationOffset_1) {
                                _this.models[0].rootMesh.rotationQuaternion = _this.models[0].rootMesh.rotationQuaternion || new Quaternion();
                                rotationOffset_1 = controller.mesh.rotationQuaternion.conjugate().multiply(_this.models[0].rootMesh.rotationQuaternion);
                            }
                        }
                        else {
                            rotationOffset_1 = null;
                        }
                    }
                });
                _this.scene.registerBeforeRender(function () {
                    if (_this.models[0]) {
                        if (rotationOffset_1 && controller.mesh && controller.mesh.rotationQuaternion) {
                            _this.models[0].rootMesh.rotationQuaternion.copyFrom(controller.mesh.rotationQuaternion).multiplyInPlace(rotationOffset_1);
                        }
                        else {
                            _this.models[0].rootMesh.rotationQuaternion = null;
                        }
                    }
                });
            });
        }
        this._vrHelper.onEnteringVRObservable.add(function () {
            if (_this._observablesManager) {
                _this._observablesManager.onEnteringVRObservable.notifyObservers(_this);
            }
        });
        this._vrHelper.onExitingVRObservable.add(function () {
            if (_this._observablesManager) {
                _this._observablesManager.onExitingVRObservable.notifyObservers(_this);
            }
        });
        this.onVRConfiguredObservable.notifyObservers({
            sceneManager: this,
            object: this._vrHelper,
            newConfiguration: vrConfig
        });
    };
    SceneManager.prototype._configureEnvironmentMap = function (environmentMapConfiguration) {
        if (environmentMapConfiguration.texture) {
            this.scene.environmentTexture = new CubeTexture(this._getAssetUrl(environmentMapConfiguration.texture), this.scene);
        }
        //sanity check
        if (this.scene.environmentTexture) {
            var rotatquatRotationionY = Quaternion.RotationAxis(Axis.Y, environmentMapConfiguration.rotationY || 0);
            Matrix.FromQuaternionToRef(rotatquatRotationionY, this.scene.environmentTexture.getReflectionTextureMatrix());
        }
        // process mainColor changes:
        if (environmentMapConfiguration.mainColor) {
            this._configurationContainer.mainColor = this.mainColor || Color3.White();
            var mc = environmentMapConfiguration.mainColor;
            if (mc.r !== undefined) {
                this.mainColor.r = mc.r;
            }
            if (mc.g !== undefined) {
                this.mainColor.g = mc.g;
            }
            if (mc.b !== undefined) {
                this.mainColor.b = mc.b;
            }
            this.reflectionColor.copyFrom(this.mainColor);
            var environmentTint = getConfigurationKey("environmentMap.tintLevel", this._globalConfiguration) || 0;
            // reflection color
            this.reflectionColor.toLinearSpaceToRef(this.reflectionColor);
            this.reflectionColor.scaleToRef(1 / this.scene.imageProcessingConfiguration.exposure, this.reflectionColor);
            var tmpColor3 = Color3.Lerp(this._white, this.reflectionColor, environmentTint);
            this.reflectionColor.copyFrom(tmpColor3);
            //update the environment, if exists
            if (this.environmentHelper) {
                if (this.environmentHelper.groundMaterial) {
                    this.environmentHelper.groundMaterial._perceptualColor = this.mainColor;
                }
                if (this.environmentHelper.skyboxMaterial) {
                    this.environmentHelper.skyboxMaterial._perceptualColor = this.mainColor;
                }
            }
        }
    };
    /**
     * (Re) configure the camera. The camera will only be created once and from this point will only be reconfigured.
     * @param cameraConfig the new camera configuration
     * @param model optionally use the model to configure the camera.
     */
    SceneManager.prototype._configureCamera = function (cameraConfig) {
        var _this = this;
        if (cameraConfig === void 0) { cameraConfig = {}; }
        if (!this.scene.activeCamera) {
            var attachControl = true;
            if (this._globalConfiguration.scene && this._globalConfiguration.scene.disableCameraControl) {
                attachControl = false;
            }
            // Inline scene.createDefaultCamera to reduce file size
            // Dispose existing camera in replace mode.
            if (this.scene.activeCamera) {
                this.scene.activeCamera.dispose();
                this.scene.activeCamera = null;
            }
            // Camera
            if (!this.scene.activeCamera) {
                var worldExtends = this.scene.getWorldExtends();
                var worldSize = worldExtends.max.subtract(worldExtends.min);
                var worldCenter = worldExtends.min.add(worldSize.scale(0.5));
                var camera;
                var radius = worldSize.length() * 1.5;
                // empty scene scenario!
                if (!isFinite(radius)) {
                    radius = 1;
                    worldCenter.copyFromFloats(0, 0, 0);
                }
                var arcRotateCamera = new ArcRotateCamera("default camera", -(Math.PI / 2), Math.PI / 2, radius, worldCenter, this.scene);
                arcRotateCamera.lowerRadiusLimit = radius * 0.01;
                arcRotateCamera.wheelPrecision = 100 / radius;
                camera = arcRotateCamera;
                camera.minZ = radius * 0.01;
                camera.maxZ = radius * 1000;
                camera.speed = radius * 0.2;
                this.scene.activeCamera = camera;
            }
            var canvas = this.scene.getEngine().getInputElement();
            if (canvas) {
                this.scene.activeCamera.attachControl(canvas);
            }
            this.camera = this.scene.activeCamera;
            this.camera.setTarget(Vector3.Zero());
        }
        if (!this.camera) {
            this.camera = this.scene.activeCamera;
        }
        if (cameraConfig.position) {
            var newPosition = this.camera.position.clone();
            extendClassWithConfig(newPosition, cameraConfig.position);
            this.camera.setPosition(newPosition);
        }
        if (cameraConfig.target) {
            var newTarget = this.camera.target.clone();
            extendClassWithConfig(newTarget, cameraConfig.target);
            this.camera.setTarget(newTarget);
        } /*else if (this.models.length && !cameraConfig.disableAutoFocus) {
            this._focusOnModel(this.models[0]);
        }*/
        if (cameraConfig.rotation) {
            this.camera.rotationQuaternion = new Quaternion(cameraConfig.rotation.x || 0, cameraConfig.rotation.y || 0, cameraConfig.rotation.z || 0, cameraConfig.rotation.w || 0);
        }
        if (cameraConfig.behaviors) {
            for (var name_1 in cameraConfig.behaviors) {
                if (cameraConfig.behaviors[name_1] !== undefined) {
                    this._setCameraBehavior(name_1, cameraConfig.behaviors[name_1]);
                }
            }
        }
        var sceneExtends = this.scene.getWorldExtends(function (mesh) {
            return !_this.environmentHelper || (mesh !== _this.environmentHelper.ground && mesh !== _this.environmentHelper.rootMesh && mesh !== _this.environmentHelper.skybox);
        });
        var sceneDiagonal = sceneExtends.max.subtract(sceneExtends.min);
        var sceneDiagonalLength = sceneDiagonal.length();
        if (isFinite(sceneDiagonalLength)) {
            this.camera.upperRadiusLimit = sceneDiagonalLength * 4;
        }
        // sanity check!
        if (this.scene.imageProcessingConfiguration) {
            this.scene.imageProcessingConfiguration.colorCurvesEnabled = true;
            this.scene.imageProcessingConfiguration.vignetteEnabled = true;
            this.scene.imageProcessingConfiguration.toneMappingEnabled = !!getConfigurationKey("camera.toneMappingEnabled", this._globalConfiguration);
        }
        extendClassWithConfig(this.camera, cameraConfig);
        this.onCameraConfiguredObservable.notifyObservers({
            sceneManager: this,
            object: this.camera,
            newConfiguration: cameraConfig
        });
    };
    SceneManager.prototype._configureEnvironment = function (skyboxConifguration, groundConfiguration) {
        var _this = this;
        if (!skyboxConifguration && !groundConfiguration) {
            if (this.environmentHelper) {
                this.environmentHelper.dispose();
                this.environmentHelper = undefined;
            }
        }
        else {
            var options = {
                createGround: !!groundConfiguration && this._groundEnabled,
                createSkybox: !!skyboxConifguration,
                setupImageProcessing: false,
            };
            // will that cause problems with model ground configuration?
            /*if (model) {
                const boundingInfo = model.rootMesh.getHierarchyBoundingVectors(true);
                const sizeVec = boundingInfo.max.subtract(boundingInfo.min);
                const halfSizeVec = sizeVec.scale(0.5);
                const center = boundingInfo.min.add(halfSizeVec);
                options.groundYBias = -center.y;
            }*/
            if (groundConfiguration) {
                var groundConfig_1 = (typeof groundConfiguration === 'boolean') ? {} : groundConfiguration;
                var groundSize = groundConfig_1.size || (typeof skyboxConifguration === 'object' && skyboxConifguration.scale);
                if (groundSize) {
                    options.groundSize = groundSize;
                }
                options.enableGroundShadow = groundConfig_1 === true || groundConfig_1.receiveShadows;
                if (groundConfig_1.shadowLevel !== undefined) {
                    options.groundShadowLevel = groundConfig_1.shadowLevel;
                }
                options.enableGroundMirror = !!groundConfig_1.mirror && this.groundMirrorEnabled;
                if (groundConfig_1.texture) {
                    options.groundTexture = this._getAssetUrl(groundConfig_1.texture);
                }
                if (groundConfig_1.color) {
                    options.groundColor = new Color3(groundConfig_1.color.r, groundConfig_1.color.g, groundConfig_1.color.b);
                }
                if (groundConfig_1.opacity !== undefined) {
                    options.groundOpacity = groundConfig_1.opacity;
                }
                if (groundConfig_1.mirror) {
                    options.enableGroundMirror = true;
                    // to prevent undefines
                    if (typeof groundConfig_1.mirror === "object") {
                        if (groundConfig_1.mirror.amount !== undefined) {
                            options.groundMirrorAmount = groundConfig_1.mirror.amount;
                        }
                        if (groundConfig_1.mirror.sizeRatio !== undefined) {
                            options.groundMirrorSizeRatio = groundConfig_1.mirror.sizeRatio;
                        }
                        if (groundConfig_1.mirror.blurKernel !== undefined) {
                            options.groundMirrorBlurKernel = groundConfig_1.mirror.blurKernel;
                        }
                        if (groundConfig_1.mirror.fresnelWeight !== undefined) {
                            options.groundMirrorFresnelWeight = groundConfig_1.mirror.fresnelWeight;
                        }
                        if (groundConfig_1.mirror.fallOffDistance !== undefined) {
                            options.groundMirrorFallOffDistance = groundConfig_1.mirror.fallOffDistance;
                        }
                        if (this._defaultPipelineTextureType !== undefined) {
                            options.groundMirrorTextureType = this._defaultPipelineTextureType;
                        }
                    }
                }
            }
            var postInitSkyboxMaterial = false;
            if (skyboxConifguration) {
                var conf = skyboxConifguration === true ? {} : skyboxConifguration;
                if (conf.material && conf.material.imageProcessingConfiguration) {
                    options.setupImageProcessing = false; // will be configured later manually.
                }
                var skyboxSize = conf.scale;
                if (skyboxSize) {
                    options.skyboxSize = skyboxSize;
                }
                options.sizeAuto = !options.skyboxSize;
                if (conf.color) {
                    options.skyboxColor = new Color3(conf.color.r, conf.color.g, conf.color.b);
                }
                if (conf.cubeTexture && conf.cubeTexture.url) {
                    if (typeof conf.cubeTexture.url === "string") {
                        options.skyboxTexture = this._getAssetUrl(conf.cubeTexture.url);
                    }
                    else {
                        // init later!
                        postInitSkyboxMaterial = true;
                    }
                }
                if (conf.material) {
                    postInitSkyboxMaterial = true;
                }
            }
            options.setupImageProcessing = false; // TMP
            if (!this.environmentHelper) {
                this.environmentHelper = new EnvironmentHelper(options, this.scene);
            }
            else {
                // unlikely, but there might be a new scene! we need to dispose.
                // get the scene used by the envHelper
                var scene = this.environmentHelper.rootMesh.getScene();
                // is it a different scene? Oh no!
                if (scene !== this.scene) {
                    this.environmentHelper.dispose();
                    this.environmentHelper = new EnvironmentHelper(options, this.scene);
                }
                else {
                    // recreate the ground
                    if (this.environmentHelper.ground) {
                        this.environmentHelper.ground.dispose();
                    }
                    // recreate the skybox
                    if (this.environmentHelper.skybox) {
                        this.environmentHelper.skybox.dispose();
                    }
                    this.environmentHelper.updateOptions(options);
                    // update doesn't change the size of the skybox and ground, so we have to recreate!
                    //this.environmentHelper.dispose();
                    //this.environmentHelper = new EnvironmentHelper(options, this.scene);
                }
            }
            if (this.environmentHelper.rootMesh && this._globalConfiguration.scene && this._globalConfiguration.scene.environmentRotationY !== undefined) {
                this.environmentHelper.rootMesh.rotation.y = this._globalConfiguration.scene.environmentRotationY;
            }
            var groundConfig = (typeof groundConfiguration === 'boolean') ? {} : groundConfiguration;
            if (this.environmentHelper.groundMaterial && groundConfig) {
                this.environmentHelper.groundMaterial._perceptualColor = this.mainColor;
                if (groundConfig.material) {
                    extendClassWithConfig(this.environmentHelper.groundMaterial, groundConfig.material);
                }
                if (this.environmentHelper.groundMirror) {
                    var mirrorClearColor = this.environmentHelper.groundMaterial._perceptualColor.toLinearSpace();
                    // TODO user camera exposure value to set the mirror clear color
                    var exposure = Math.pow(2.0, -this.scene.imageProcessingConfiguration.exposure) * Math.PI;
                    mirrorClearColor.scaleToRef(1 / exposure, mirrorClearColor);
                    this.environmentHelper.groundMirror.clearColor.r = Scalar.Clamp(mirrorClearColor.r);
                    this.environmentHelper.groundMirror.clearColor.g = Scalar.Clamp(mirrorClearColor.g);
                    this.environmentHelper.groundMirror.clearColor.b = Scalar.Clamp(mirrorClearColor.b);
                    this.environmentHelper.groundMirror.clearColor.a = 1;
                    if (!this.groundMirrorEnabled) {
                        this.environmentHelper.groundMaterial.reflectionTexture = null;
                    }
                }
            }
            var skyboxMaterial = this.environmentHelper.skyboxMaterial;
            if (skyboxMaterial) {
                skyboxMaterial._perceptualColor = this.mainColor;
                if (postInitSkyboxMaterial) {
                    if (typeof skyboxConifguration === 'object' && skyboxConifguration.material) {
                        extendClassWithConfig(skyboxMaterial, skyboxConifguration.material);
                    }
                }
            }
        }
        this._observablesManager && this._observablesManager.onModelLoadedObservable.add(function (model) {
            _this._updateGroundMirrorRenderList(model);
        });
        this.onEnvironmentConfiguredObservable.notifyObservers({
            sceneManager: this,
            object: this.environmentHelper,
            newConfiguration: {
                skybox: skyboxConifguration,
                ground: groundConfiguration
            }
        });
    };
    /**
     * configure the lights.
     *
     * @param lightsConfiguration the (new) light(s) configuration
     * @param model optionally use the model to configure the camera.
     */
    SceneManager.prototype._configureLights = function (lightsConfiguration) {
        var _this = this;
        if (lightsConfiguration === void 0) { lightsConfiguration = {}; }
        // sanity check!
        var lightKeys = Object.keys(lightsConfiguration).filter(function (name) { return name !== 'globalRotation'; });
        if (!lightKeys.length) {
            if (!this.scene.lights.length) {
                new HemisphericLight("default light", Vector3.Up(), this.scene);
            }
        }
        else {
            var lightsAvailable_1 = this.scene.lights.map(function (light) { return light.name; });
            // compare to the global (!) configuration object and dispose unneeded:
            var lightsToConfigure_1 = Object.keys(this._globalConfiguration.lights || []);
            if (Object.keys(lightsToConfigure_1).length !== lightsAvailable_1.length) {
                lightsAvailable_1.forEach(function (lName) {
                    if (lightsToConfigure_1.indexOf(lName) === -1) {
                        _this.scene.getLightByName(lName).dispose();
                    }
                });
            }
            lightKeys.forEach(function (name, idx) {
                var lightConfig = { type: 0 };
                if (typeof lightsConfiguration[name] === 'object') {
                    lightConfig = lightsConfiguration[name];
                }
                if (typeof lightsConfiguration[name] === 'number') {
                    lightConfig.type = lightsConfiguration[name];
                }
                lightConfig.name = name;
                var light;
                // light is not already available
                if (lightsAvailable_1.indexOf(name) === -1) {
                    var constructor = Light.GetConstructorFromName(lightConfig.type, lightConfig.name, _this.scene);
                    if (!constructor) {
                        return;
                    }
                    light = constructor();
                }
                else {
                    // available? get it from the scene
                    light = _this.scene.getLightByName(name);
                    if (typeof lightsConfiguration[name] === 'boolean') {
                        lightConfig.type = light.getTypeID();
                    }
                    lightsAvailable_1 = lightsAvailable_1.filter(function (ln) { return ln !== name; });
                    if (lightConfig.type !== undefined && light.getTypeID() !== lightConfig.type) {
                        light.dispose();
                        var constructor = Light.GetConstructorFromName(lightConfig.type, lightConfig.name, _this.scene);
                        if (!constructor) {
                            return;
                        }
                        light = constructor();
                    }
                }
                // if config set the light to false, dispose it.
                if (lightsConfiguration[name] === false) {
                    light.dispose();
                    return;
                }
                //enabled
                var enabled = lightConfig.enabled !== undefined ? lightConfig.enabled : !lightConfig.disabled;
                light.setEnabled(enabled);
                extendClassWithConfig(light, lightConfig);
                //position. Some lights don't support shadows
                if (light instanceof ShadowLight) {
                    // set default values
                    light.shadowMinZ = light.shadowMinZ || 0.2;
                    light.shadowMaxZ = Math.min(10, light.shadowMaxZ || 10); //large far clips reduce shadow depth precision
                    if (lightConfig.target) {
                        if (light.setDirectionToTarget) {
                            var target = Vector3.Zero().copyFrom(lightConfig.target);
                            light.setDirectionToTarget(target);
                        }
                    }
                    else if (lightConfig.direction) {
                        var direction = Vector3.Zero().copyFrom(lightConfig.direction);
                        light.direction = direction;
                    }
                    var isShadowEnabled = false;
                    if (light.getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
                        light.shadowFrustumSize = lightConfig.shadowFrustumSize || 2;
                        isShadowEnabled = true;
                    }
                    else if (light.getTypeID() === Light.LIGHTTYPEID_SPOTLIGHT) {
                        var spotLight = light;
                        if (lightConfig.spotAngle !== undefined) {
                            spotLight.angle = lightConfig.spotAngle * Math.PI / 180;
                        }
                        if (spotLight.angle && lightConfig.shadowFieldOfView) {
                            spotLight.shadowAngleScale = lightConfig.shadowFieldOfView / spotLight.angle;
                        }
                        isShadowEnabled = true;
                    }
                    else if (light.getTypeID() === Light.LIGHTTYPEID_POINTLIGHT) {
                        if (lightConfig.shadowFieldOfView) {
                            light.shadowAngle = lightConfig.shadowFieldOfView * Math.PI / 180;
                        }
                        isShadowEnabled = true;
                    }
                    var shadowGenerator_1 = light.getShadowGenerator();
                    if (isShadowEnabled && lightConfig.shadowEnabled && _this._maxShadows) {
                        var bufferSize = lightConfig.shadowBufferSize || 256;
                        if (!shadowGenerator_1) {
                            shadowGenerator_1 = new ShadowGenerator(bufferSize, light);
                        }
                        var blurKernel = _this.getBlurKernel(light, bufferSize);
                        shadowGenerator_1.bias = _this._shadowGeneratorBias;
                        shadowGenerator_1.blurKernel = blurKernel;
                        //override defaults
                        extendClassWithConfig(shadowGenerator_1, lightConfig.shadowConfig || {});
                        // add the focues meshes to the shadow list
                        _this._observablesManager && _this._observablesManager.onModelLoadedObservable.add(function (model) {
                            _this._updateShadowRenderList(shadowGenerator_1, model);
                        });
                        //if (model) {
                        _this._updateShadowRenderList(shadowGenerator_1);
                        //}
                    }
                    else if (shadowGenerator_1) {
                        shadowGenerator_1.dispose();
                    }
                }
            });
            // render priority
            var globalLightsConfiguration_1 = this._globalConfiguration.lights || {};
            Object.keys(globalLightsConfiguration_1).sort().forEach(function (name, idx) {
                var configuration = globalLightsConfiguration_1[name];
                var light = _this.scene.getLightByName(name);
                // sanity check
                if (!light) {
                    return;
                }
                light.renderPriority = -idx;
            });
        }
        this.onLightsConfiguredObservable.notifyObservers({
            sceneManager: this,
            object: this.scene.lights,
            newConfiguration: lightsConfiguration
        });
    };
    SceneManager.prototype._updateShadowRenderList = function (shadowGenerator, model, resetList) {
        var focusMeshes = model ? model.meshes : this.scene.meshes;
        // add the focues meshes to the shadow list
        var shadownMap = shadowGenerator.getShadowMap();
        if (!shadownMap) {
            return;
        }
        if (resetList && shadownMap.renderList) {
            shadownMap.renderList.length = 0;
        }
        else {
            shadownMap.renderList = shadownMap.renderList || [];
        }
        for (var index = 0; index < focusMeshes.length; index++) {
            var mesh = focusMeshes[index];
            if (Tags.MatchesQuery(mesh, 'castShadow') && shadownMap.renderList.indexOf(mesh) === -1) {
                shadownMap.renderList.push(mesh);
            }
        }
        if (!this._shadowGroundPlane) {
            if (shadowGenerator.useBlurCloseExponentialShadowMap) {
                var shadowGroundPlane = Mesh.CreatePlane("shadowGroundPlane", 100, this.scene, false);
                shadowGroundPlane.useVertexColors = false;
                //material isn't ever used in rendering, just used to set back face culling
                shadowGroundPlane.material = new PBRMaterial('shadowGroundPlaneMaterial', this.scene);
                shadowGroundPlane.material.backFaceCulling = false;
                shadowGroundPlane.rotation.x = Math.PI * 0.5;
                shadowGroundPlane.freezeWorldMatrix();
                this._shadowGroundPlane = shadowGroundPlane;
                this.scene.removeMesh(shadowGroundPlane);
            }
        }
        else {
            if (!shadowGenerator.useBlurCloseExponentialShadowMap) {
                this._shadowGroundPlane.dispose();
                this._shadowGroundPlane = null;
            }
        }
        if (this._shadowGroundPlane && shadownMap.renderList.indexOf(this._shadowGroundPlane) === -1) {
            shadownMap.renderList.push(this._shadowGroundPlane);
        }
    };
    SceneManager.prototype._updateGroundMirrorRenderList = function (model, resetList) {
        if (this.environmentHelper && this.environmentHelper.groundMirror && this.environmentHelper.groundMirror.renderList) {
            var focusMeshes = model ? model.meshes : this.scene.meshes;
            var renderList = this.environmentHelper.groundMirror.renderList;
            if (resetList) {
                renderList.length = 0;
            }
            for (var index = 0; index < focusMeshes.length; index++) {
                var mesh = focusMeshes[index];
                if (renderList.indexOf(mesh) === -1) {
                    renderList.push(mesh);
                }
            }
        }
    };
    /**
     * Gets the shadow map blur kernel according to the light configuration.
     * @param light The light used to generate the shadows
     * @param bufferSize The size of the shadow map
     * @return the kernel blur size
     */
    SceneManager.prototype.getBlurKernel = function (light, bufferSize) {
        var normalizedBlurKernel = 0.05; // TODO Should come from the config.
        if (light.getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
            normalizedBlurKernel = normalizedBlurKernel / light.shadowFrustumSize;
        }
        else if (light.getTypeID() === Light.LIGHTTYPEID_POINTLIGHT) {
            normalizedBlurKernel = normalizedBlurKernel / light.shadowAngle;
        }
        else if (light.getTypeID() === Light.LIGHTTYPEID_SPOTLIGHT) {
            normalizedBlurKernel = normalizedBlurKernel / (light.angle * light.shadowAngleScale);
        }
        var minimumBlurKernel = 5 / (bufferSize / 256); //magic number that aims to keep away sawtooth shadows
        var blurKernel = Math.max(bufferSize * normalizedBlurKernel, minimumBlurKernel);
        return blurKernel;
    };
    /**
     * Alters render settings to reduce features based on hardware feature limitations
     * @param enableHDR Allows the viewer to run in HDR mode.
     */
    SceneManager.prototype._handleHardwareLimitations = function (enableHDR) {
        if (enableHDR === void 0) { enableHDR = true; }
        //flip rendering settings switches based on hardware support
        var maxVaryingRows = this._engine.getCaps().maxVaryingVectors;
        var maxFragmentSamplers = this._engine.getCaps().maxTexturesImageUnits;
        //shadows are disabled if there's not enough varyings for a single shadow
        if ((maxVaryingRows < 8) || (maxFragmentSamplers < 8)) {
            this._maxShadows = 0;
        }
        else {
            this._maxShadows = 3;
        }
        //can we render to any >= 16-bit targets (required for HDR)
        var caps = this._engine.getCaps();
        var linearHalfFloatTargets = caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering;
        var linearFloatTargets = caps.textureFloatRender && caps.textureFloatLinearFiltering;
        this._hdrSupport = enableHDR && !!(linearFloatTargets || linearHalfFloatTargets);
        if (linearHalfFloatTargets) {
            this._defaultHighpTextureType = Constants.TEXTURETYPE_HALF_FLOAT;
            this._shadowGeneratorBias = 0.002;
        }
        else if (linearFloatTargets) {
            this._defaultHighpTextureType = Constants.TEXTURETYPE_FLOAT;
            this._shadowGeneratorBias = 0.001;
        }
        else {
            this._defaultHighpTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;
            this._shadowGeneratorBias = 0.001;
        }
        this._defaultPipelineTextureType = this._hdrSupport ? this._defaultHighpTextureType : Constants.TEXTURETYPE_UNSIGNED_INT;
    };
    /**
     * Dispoe the entire viewer including the scene and the engine
     */
    SceneManager.prototype.dispose = function () {
        // this.onCameraConfiguredObservable.clear();
        this.onEnvironmentConfiguredObservable.clear();
        this.onLightsConfiguredObservable.clear();
        this.onModelsConfiguredObservable.clear();
        this.onSceneConfiguredObservable.clear();
        this.onSceneInitObservable.clear();
        this.onSceneOptimizerConfiguredObservable.clear();
        this.onVRConfiguredObservable.clear();
        if (this.sceneOptimizer) {
            this.sceneOptimizer.stop();
            this.sceneOptimizer.dispose();
        }
        if (this.environmentHelper) {
            this.environmentHelper.dispose();
        }
        this.models.forEach(function (model) {
            model.dispose();
        });
        if (this._defaultRenderingPipeline) {
            this._defaultRenderingPipeline.dispose();
        }
        this.models.length = 0;
        if (this.scene) {
            this.scene.dispose();
        }
    };
    /**
     * Get an environment asset url by using the configuration if the path is not absolute.
     * @param url Asset url
     * @returns The Asset url using the `environmentAssetsRootURL` if the url is not an absolute path.
     */
    SceneManager.prototype._getAssetUrl = function (url) {
        var returnUrl = url;
        if (url && url.toLowerCase().indexOf("//") === -1) {
            if (!this._assetsRootURL) {
                // Tools.Warn("Please, specify the root url of your assets before loading the configuration (labs.environmentAssetsRootURL) or disable the background through the viewer options.");
                return url;
            }
            returnUrl = this._assetsRootURL + returnUrl;
        }
        return returnUrl;
    };
    SceneManager.prototype._setCameraBehavior = function (name, behaviorConfig, payload) {
        var behavior;
        var type;
        if (typeof behaviorConfig === 'object') {
            type = behaviorConfig.type;
        }
        else if (typeof behaviorConfig === 'number') {
            type = behaviorConfig;
        }
        else {
            type = this._cameraBehaviorMapping[name];
        }
        if (type === undefined) {
            return;
        }
        var config = (typeof behaviorConfig === "object") ? behaviorConfig : {};
        var enabled = true;
        if (typeof behaviorConfig === 'boolean') {
            enabled = behaviorConfig;
        }
        // constructing behavior
        switch (type) {
            case 0 /* AUTOROTATION */:
                this.camera.useAutoRotationBehavior = enabled;
                behavior = this.camera.autoRotationBehavior;
                break;
            case 1 /* BOUNCING */:
                this.camera.useBouncingBehavior = enabled;
                behavior = this.camera.bouncingBehavior;
                break;
            case 2 /* FRAMING */:
                this.camera.useFramingBehavior = enabled;
                behavior = this.camera.framingBehavior;
                break;
            default:
                behavior = null;
                break;
        }
        if (behavior) {
            this._cameraBehaviorMapping[name] = type;
            if (typeof behaviorConfig === "object") {
                extendClassWithConfig(behavior, behaviorConfig);
            }
        }
        // post attach configuration. Some functionalities require the attached camera.
        switch (type) {
            case 0 /* AUTOROTATION */:
                break;
            case 1 /* BOUNCING */:
                break;
            case 2 /* FRAMING */:
                this._observablesManager && this._observablesManager.onModelLoadedObservable.add(function (model) {
                    if (config.zoomOnBoundingInfo) {
                        behavior.zoomOnMeshHierarchy(model.rootMesh);
                    }
                });
                break;
        }
    };
    return SceneManager;
}());
export { SceneManager };
//# sourceMappingURL=sceneManager.js.map