import { mapperManager } from './mappers';
import { processConfigurationCompatibility } from './configurationCompatibility';
import { deepmerge } from '../helper';
import { Tools } from '@babylonjs/core/Misc/tools';
import { extendedConfiguration } from './types/extended';
import { renderOnlyDefaultConfiguration } from './types/renderOnlyDefault';
/**
 * The configuration loader will load the configuration object from any source and will use the defined mapper to
 * parse the object and return a conform ViewerConfiguration.
 * It is a private member of the scene.
 */
var RenderOnlyConfigurationLoader = /** @class */ (function () {
    function RenderOnlyConfigurationLoader(_enableCache) {
        if (_enableCache === void 0) { _enableCache = false; }
        this._enableCache = _enableCache;
        this._configurationCache = {};
        this._loadRequests = [];
    }
    RenderOnlyConfigurationLoader.prototype._getConfigurationTypeExcludeTemplate = function (types) {
        var _this = this;
        var config = {};
        var typesSeparated = types.split(",");
        typesSeparated.forEach(function (type) {
            switch (type.trim()) {
                case 'default':
                    config = deepmerge(config, renderOnlyDefaultConfiguration);
                    break;
                case 'none':
                    break;
                case 'extended':
                default:
                    config = deepmerge(config, extendedConfiguration);
                    break;
            }
            if (config.extends) {
                config = deepmerge(config, _this._getConfigurationTypeExcludeTemplate(config.extends));
            }
        });
        return config;
    };
    ;
    RenderOnlyConfigurationLoader.prototype.getExtendedConfig = function (type) {
        return this._getConfigurationTypeExcludeTemplate(type || "extended");
    };
    /**
     * load a configuration object that is defined in the initial configuration provided.
     * The viewer configuration can extend different types of configuration objects and have an extra configuration defined.
     *
     * @param initConfig the initial configuration that has the definitions of further configuration to load.
     * @param callback an optional callback that will be called sync, if noconfiguration needs to be loaded or configuration is payload-only
     * @returns A promise that delivers the extended viewer configuration, when done.
     */
    RenderOnlyConfigurationLoader.prototype.loadConfiguration = function (initConfig, callback) {
        var _this = this;
        if (initConfig === void 0) { initConfig = {}; }
        var loadedConfig = deepmerge({}, initConfig);
        this._processInitialConfiguration(loadedConfig);
        var extendedConfiguration = this.getExtendedConfig(loadedConfig.extends);
        if (loadedConfig.configuration) {
            var mapperType_1 = "json";
            return Promise.resolve().then(function () {
                if (typeof loadedConfig.configuration === "string" || (loadedConfig.configuration && loadedConfig.configuration.url)) {
                    // a file to load
                    var url = '';
                    if (typeof loadedConfig.configuration === "string") {
                        url = loadedConfig.configuration;
                    }
                    // if configuration is an object
                    if (typeof loadedConfig.configuration === "object" && loadedConfig.configuration.url) {
                        url = loadedConfig.configuration.url;
                        var type = loadedConfig.configuration.mapper;
                        // empty string?
                        if (!type) {
                            // load mapper type from filename / url
                            type = loadedConfig.configuration.url.split('.').pop();
                        }
                        mapperType_1 = type || mapperType_1;
                    }
                    return _this._loadFile(url);
                }
                else {
                    if (typeof loadedConfig.configuration === "object") {
                        mapperType_1 = loadedConfig.configuration.mapper || mapperType_1;
                        return loadedConfig.configuration.payload || {};
                    }
                    return {};
                }
            }).then(function (data) {
                var mapper = mapperManager.getMapper(mapperType_1);
                var parsed = deepmerge(mapper.map(data), loadedConfig);
                var merged = deepmerge(extendedConfiguration, parsed);
                processConfigurationCompatibility(merged);
                if (callback) {
                    callback(merged);
                }
                return merged;
            });
        }
        else {
            loadedConfig = deepmerge(extendedConfiguration, loadedConfig);
            processConfigurationCompatibility(loadedConfig);
            if (callback) {
                callback(loadedConfig);
            }
            return Promise.resolve(loadedConfig);
        }
    };
    /**
     * Dispose the configuration loader. This will cancel file requests, if active.
     */
    RenderOnlyConfigurationLoader.prototype.dispose = function () {
        this._loadRequests.forEach(function (request) {
            request.abort();
        });
        this._loadRequests.length = 0;
    };
    /**
     * This function will process the initial configuration and make needed changes for the viewer to work.
     * @param config the mutable(!) initial configuration to process
     */
    RenderOnlyConfigurationLoader.prototype._processInitialConfiguration = function (config) {
        if (config.model) {
            if (typeof config.model === "string") {
                config.model = {
                    url: config.model
                };
            }
        }
    };
    RenderOnlyConfigurationLoader.prototype._loadFile = function (url) {
        var _this = this;
        var cacheReference = this._configurationCache;
        if (this._enableCache && cacheReference[url]) {
            return Promise.resolve(cacheReference[url]);
        }
        return new Promise(function (resolve, reject) {
            var fileRequest = Tools.LoadFile(url, function (result) {
                var idx = _this._loadRequests.indexOf(fileRequest);
                if (idx !== -1) {
                    _this._loadRequests.splice(idx, 1);
                }
                if (_this._enableCache) {
                    cacheReference[url] = result;
                }
                resolve(result);
            }, undefined, undefined, false, function (request, error) {
                var idx = _this._loadRequests.indexOf(fileRequest);
                if (idx !== -1) {
                    _this._loadRequests.splice(idx, 1);
                }
                reject(error);
            });
            _this._loadRequests.push(fileRequest);
        });
    };
    return RenderOnlyConfigurationLoader;
}());
export { RenderOnlyConfigurationLoader };
//# sourceMappingURL=renderOnlyLoader.js.map