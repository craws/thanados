import { CubeTexture } from "@babylonjs/core/Materials/Textures/cubeTexture";
import { InternalTexture, InternalTextureSource } from "@babylonjs/core/Materials/Textures/internalTexture";
import { Scalar } from "@babylonjs/core/Maths/math.scalar";
import { Texture } from "@babylonjs/core/Materials/Textures/texture";
/**
 * A minimal WebGL cubemap descriptor
 */
var TextureCube = /** @class */ (function () {
    /**
     * constructor
     * @param internalFormat WebGL pixel format for the texture on the GPU
     * @param type WebGL pixel type of the supplied data and texture on the GPU
     * @param source An array containing mipmap levels of faces, where each mipmap level is an array of faces and each face is a TextureSource object
     */
    function TextureCube(internalFormat, type, source) {
        if (source === void 0) { source = []; }
        this.internalFormat = internalFormat;
        this.type = type;
        this.source = source;
    }
    Object.defineProperty(TextureCube.prototype, "Width", {
        /**
         * Returns the width of a face of the texture or 0 if not available
         */
        get: function () {
            return (this.source && this.source[0] && this.source[0][0]) ? this.source[0][0].width : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureCube.prototype, "Height", {
        /**
         * Returns the height of a face of the texture or 0 if not available
         */
        get: function () {
            return (this.source && this.source[0] && this.source[0][0]) ? this.source[0][0].height : 0;
        },
        enumerable: true,
        configurable: true
    });
    return TextureCube;
}());
export { TextureCube };
/**
     * A static class providing methods to aid working with Bablyon textures.
     */
var TextureUtils = /** @class */ (function () {
    function TextureUtils() {
    }
    /**
     * Returns a BabylonCubeTexture instance from a Spectre texture cube, subject to sampling parameters.
     * If such a texture has already been requested in the past, this texture will be returned, otherwise a new one will be created.
     * The advantage of this is to enable working with texture objects without the need to initialize on the GPU until desired.
     * @param scene A Babylon Scene instance
     * @param textureCube A Spectre TextureCube object
     * @param parameters WebGL texture sampling parameters
     * @param automaticMipmaps Pass true to enable automatic mipmap generation where possible (requires power of images)
     * @param environment Specifies that the texture will be used as an environment
     * @param singleLod Specifies that the texture will be a singleLod (for environment)
     * @return Babylon cube texture
     */
    TextureUtils.GetBabylonCubeTexture = function (scene, textureCube, automaticMipmaps, environment, singleLod) {
        if (environment === void 0) { environment = false; }
        if (singleLod === void 0) { singleLod = false; }
        if (!textureCube) {
            throw new Error("no texture cube provided");
        }
        var parameters;
        if (environment) {
            parameters = singleLod ? TextureUtils._EnvironmentSingleMipSampling : TextureUtils._EnvironmentSampling;
        }
        else {
            parameters = {
                magFilter: 9728 /* NEAREST */,
                minFilter: 9728 /* NEAREST */,
                wrapS: 33071 /* CLAMP_TO_EDGE */,
                wrapT: 33071 /* CLAMP_TO_EDGE */
            };
        }
        var key = TextureUtils.BabylonTextureKeyPrefix + parameters.magFilter + '' + parameters.minFilter + '' + parameters.wrapS + '' + parameters.wrapT;
        var babylonTexture = textureCube[key];
        if (!babylonTexture) {
            //initialize babylon texture
            babylonTexture = new CubeTexture('', scene);
            if (environment) {
                babylonTexture.lodGenerationOffset = TextureUtils.EnvironmentLODOffset;
                babylonTexture.lodGenerationScale = TextureUtils.EnvironmentLODScale;
            }
            babylonTexture.gammaSpace = false;
            var internalTexture_1 = new InternalTexture(scene.getEngine(), InternalTextureSource.CubeRaw);
            var glTexture_1 = internalTexture_1._webGLTexture;
            //babylon properties
            internalTexture_1.isCube = true;
            internalTexture_1.generateMipMaps = false;
            babylonTexture._texture = internalTexture_1;
            TextureUtils.ApplySamplingParameters(babylonTexture, parameters);
            var maxMipLevel_1 = automaticMipmaps ? 0 : textureCube.source.length - 1;
            var texturesUploaded_1 = 0;
            var textureComplete = function () {
                return texturesUploaded_1 === ((maxMipLevel_1 + 1) * 6);
            };
            var uploadFace = function (i, level, face) {
                if (!glTexture_1) {
                    return;
                }
                if (i === 0 && level === 0) {
                    internalTexture_1.width = face.width;
                    internalTexture_1.height = face.height;
                }
                var gl = (scene.getEngine())._gl;
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, glTexture_1);
                scene.getEngine()._unpackFlipY(false);
                if (face instanceof HTMLElement || face instanceof ImageData) {
                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, textureCube.internalFormat, textureCube.internalFormat, textureCube.type, face);
                }
                else {
                    var textureData = face;
                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, textureCube.internalFormat, textureData.width, textureData.height, 0, textureData.format, textureCube.type, textureData.data);
                }
                texturesUploaded_1++;
                if (textureComplete()) {
                    //generate mipmaps
                    if (automaticMipmaps) {
                        var w = face.width;
                        var h = face.height;
                        var isPot = (((w !== 0) && (w & (w - 1))) === 0) && (((h !== 0) && (h & (h - 1))) === 0);
                        if (isPot) {
                            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
                        }
                    }
                    // Upload Separate lods in case there is no support for texture lod.
                    if (environment && !scene.getEngine().getCaps().textureLOD && !singleLod) {
                        var mipSlices = 3;
                        for (var i_1 = 0; i_1 < mipSlices; i_1++) {
                            var lodKey = TextureUtils.BabylonTextureKeyPrefix + 'lod' + i_1;
                            var lod = textureCube[lodKey];
                            //initialize lod texture if it doesn't already exist
                            if (lod == null && textureCube.Width) {
                                //compute LOD from even spacing in smoothness (matching shader calculation)
                                var smoothness = i_1 / (mipSlices - 1);
                                var roughness = 1 - smoothness;
                                var kMinimumVariance = 0.0005;
                                var alphaG = roughness * roughness + kMinimumVariance;
                                var microsurfaceAverageSlopeTexels = alphaG * textureCube.Width;
                                var environmentSpecularLOD = TextureUtils.EnvironmentLODScale * (Scalar.Log2(microsurfaceAverageSlopeTexels)) + TextureUtils.EnvironmentLODOffset;
                                var maxLODIndex = textureCube.source.length - 1;
                                var mipmapIndex = Math.min(Math.max(Math.round(environmentSpecularLOD), 0), maxLODIndex);
                                lod = TextureUtils.GetBabylonCubeTexture(scene, new TextureCube(6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, [textureCube.source[mipmapIndex]]), false, true, true);
                                if (i_1 === 0) {
                                    internalTexture_1._lodTextureLow = lod;
                                }
                                else if (i_1 === 1) {
                                    internalTexture_1._lodTextureMid = lod;
                                }
                                else {
                                    internalTexture_1._lodTextureHigh = lod;
                                }
                                textureCube[lodKey] = lod;
                            }
                        }
                    }
                    internalTexture_1.isReady = true;
                }
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
                scene.getEngine().resetTextureCache();
            };
            var _loop_1 = function (i) {
                var faces = textureCube.source[i];
                var _loop_2 = function (j) {
                    var face = faces[j];
                    if (face instanceof HTMLImageElement && !face.complete) {
                        face.addEventListener('load', function () {
                            uploadFace(j, i, face);
                        }, false);
                    }
                    else {
                        uploadFace(j, i, face);
                    }
                };
                for (var j = 0; j < faces.length; j++) {
                    _loop_2(j);
                }
            };
            for (var i = 0; i <= maxMipLevel_1; i++) {
                _loop_1(i);
            }
            scene.getEngine().resetTextureCache();
            babylonTexture.isReady = function () {
                return textureComplete();
            };
            textureCube[key] = babylonTexture;
        }
        return babylonTexture;
    };
    /**
     * Applies Spectre SamplingParameters to a Babylon texture by directly setting texture parameters on the internal WebGLTexture as well as setting Babylon fields
     * @param babylonTexture Babylon texture to apply texture to (requires the Babylon texture has an initialize _texture field)
     * @param parameters Spectre SamplingParameters to apply
     */
    TextureUtils.ApplySamplingParameters = function (babylonTexture, parameters) {
        var scene = babylonTexture.getScene();
        if (!scene) {
            return;
        }
        var gl = (scene.getEngine())._gl;
        var target = babylonTexture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
        var internalTexture = babylonTexture._texture;
        if (!internalTexture) {
            return;
        }
        var glTexture = internalTexture._webGLTexture;
        gl.bindTexture(target, glTexture);
        if (parameters.magFilter != null) {
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, parameters.magFilter);
        }
        if (parameters.minFilter != null) {
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, parameters.minFilter);
        }
        if (parameters.wrapS != null) {
            gl.texParameteri(target, gl.TEXTURE_WRAP_S, parameters.wrapS);
        }
        if (parameters.wrapT != null) {
            gl.texParameteri(target, gl.TEXTURE_WRAP_T, parameters.wrapT);
        }
        //set babylon wrap modes from sampling parameter
        switch (parameters.wrapS) {
            case 10497 /* REPEAT */:
                babylonTexture.wrapU = Texture.WRAP_ADDRESSMODE;
                break;
            case 33071 /* CLAMP_TO_EDGE */:
                babylonTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
                break;
            case 33648 /* MIRRORED_REPEAT */:
                babylonTexture.wrapU = Texture.MIRROR_ADDRESSMODE;
                break;
            default: babylonTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
        }
        switch (parameters.wrapT) {
            case 10497 /* REPEAT */:
                babylonTexture.wrapV = Texture.WRAP_ADDRESSMODE;
                break;
            case 33071 /* CLAMP_TO_EDGE */:
                babylonTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
                break;
            case 33648 /* MIRRORED_REPEAT */:
                babylonTexture.wrapV = Texture.MIRROR_ADDRESSMODE;
                break;
            default: babylonTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
        }
        if (parameters.maxAnisotropy != null && parameters.maxAnisotropy > 1) {
            var anisotropicExt = gl.getExtension('EXT_texture_filter_anisotropic');
            if (anisotropicExt) {
                var maxAnisotropicSamples = gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                var maxAnisotropy = Math.min(parameters.maxAnisotropy, maxAnisotropicSamples);
                gl.texParameterf(target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);
                babylonTexture.anisotropicFilteringLevel = maxAnisotropy;
            }
        }
        gl.bindTexture(target, null);
        scene.getEngine().resetTextureCache();
    };
    /**
     * A prefix used when storing a babylon texture object reference on a Spectre texture object
     */
    TextureUtils.BabylonTextureKeyPrefix = '__babylonTexture_';
    /**
     * Controls anisotropic filtering for deserialized textures.
     */
    TextureUtils.MaxAnisotropy = 4;
    TextureUtils._EnvironmentSampling = {
        magFilter: 9729 /* LINEAR */,
        minFilter: 9987 /* LINEAR_MIPMAP_LINEAR */,
        wrapS: 33071 /* CLAMP_TO_EDGE */,
        wrapT: 33071 /* CLAMP_TO_EDGE */,
        maxAnisotropy: 1
    };
    TextureUtils._EnvironmentSingleMipSampling = {
        magFilter: 9729 /* LINEAR */,
        minFilter: 9729 /* LINEAR */,
        wrapS: 33071 /* CLAMP_TO_EDGE */,
        wrapT: 33071 /* CLAMP_TO_EDGE */,
        maxAnisotropy: 1
    };
    //from "/Internal/Lighting.EnvironmentFilterScale" in Engine/*/Configuration.cpp
    /**
     * Environment preprocessing dedicated value (Internal Use or Advanced only).
     */
    TextureUtils.EnvironmentLODScale = 0.8;
    /**
     * Environment preprocessing dedicated value (Internal Use or Advanced only)..
     */
    TextureUtils.EnvironmentLODOffset = 1.0;
    return TextureUtils;
}());
export { TextureUtils };
//# sourceMappingURL=texture.js.map