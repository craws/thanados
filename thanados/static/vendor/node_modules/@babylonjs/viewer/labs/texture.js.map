{"version":3,"file":"texture.js","sourceRoot":"","sources":["../../../../sourceES6/viewer/src/labs/texture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"@babylonjs/core/scene\";\r\nimport { CubeTexture } from \"@babylonjs/core/Materials/Textures/cubeTexture\";\r\nimport { InternalTexture, InternalTextureSource } from \"@babylonjs/core/Materials/Textures/internalTexture\";\r\nimport { Scalar } from \"@babylonjs/core/Maths/math.scalar\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\n\r\n/**\r\n * WebGL Pixel Formats\r\n */\r\nexport const enum PixelFormat {\r\n    DEPTH_COMPONENT = 0x1902,\r\n    ALPHA = 0x1906,\r\n    RGB = 0x1907,\r\n    RGBA = 0x1908,\r\n    LUMINANCE = 0x1909,\r\n    LUMINANCE_ALPHA = 0x190a,\r\n}\r\n\r\n/**\r\n * WebGL Pixel Types\r\n */\r\nexport const enum PixelType {\r\n    UNSIGNED_BYTE = 0x1401,\r\n    UNSIGNED_SHORT_4_4_4_4 = 0x8033,\r\n    UNSIGNED_SHORT_5_5_5_1 = 0x8034,\r\n    UNSIGNED_SHORT_5_6_5 = 0x8363,\r\n}\r\n\r\n/**\r\n * WebGL Texture Magnification Filter\r\n */\r\nexport const enum TextureMagFilter {\r\n    NEAREST = 0x2600,\r\n    LINEAR = 0x2601,\r\n}\r\n\r\n/**\r\n * WebGL Texture Minification Filter\r\n */\r\nexport const enum TextureMinFilter {\r\n    NEAREST = 0x2600,\r\n    LINEAR = 0x2601,\r\n    NEAREST_MIPMAP_NEAREST = 0x2700,\r\n    LINEAR_MIPMAP_NEAREST = 0x2701,\r\n    NEAREST_MIPMAP_LINEAR = 0x2702,\r\n    LINEAR_MIPMAP_LINEAR = 0x2703,\r\n}\r\n\r\n/**\r\n * WebGL Texture Wrap Modes\r\n */\r\nexport const enum TextureWrapMode {\r\n    REPEAT = 0x2901,\r\n    CLAMP_TO_EDGE = 0x812f,\r\n    MIRRORED_REPEAT = 0x8370,\r\n}\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport interface TextureData {\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n    /**\r\n     * Height of image\r\n     */\r\n    height: number;\r\n    /**\r\n     * Format of pixels in data\r\n     */\r\n    format: PixelFormat;\r\n    /**\r\n     * Row byte alignment of pixels in data\r\n     */\r\n    alignment: number;\r\n    /**\r\n     * Pixel data\r\n     */\r\n    data: ArrayBufferView;\r\n}\r\n\r\n/**\r\n * Wraps sampling parameters for a WebGL texture\r\n */\r\nexport interface SamplingParameters {\r\n    /**\r\n     * Magnification mode when upsampling from a WebGL texture\r\n     */\r\n    magFilter?: TextureMagFilter;\r\n    /**\r\n     * Minification mode when upsampling from a WebGL texture\r\n     */\r\n    minFilter?: TextureMinFilter;\r\n    /**\r\n     * X axis wrapping mode when sampling out of a WebGL texture bounds\r\n     */\r\n    wrapS?: TextureWrapMode;\r\n    /**\r\n     * Y axis wrapping mode when sampling out of a WebGL texture bounds\r\n     */\r\n    wrapT?: TextureWrapMode;\r\n    /**\r\n    * Anisotropic filtering samples\r\n    */\r\n    maxAnisotropy?: number;\r\n}\r\n\r\n/**\r\n * Represents a valid WebGL texture source for use in texImage2D\r\n */\r\nexport type TextureSource = TextureData | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;\r\n\r\n/**\r\n * A generic set of texture mipmaps (where index 0 has the largest dimension)\r\n */\r\nexport type Mipmaps<T> = Array<T>;\r\n\r\n/**\r\n * A set of 6 cubemap arranged in the order [+x, -x, +y, -y, +z, -z]\r\n */\r\nexport type Faces<T> = Array<T>;\r\n\r\n/**\r\n * A set of texture mipmaps specifically for 2D textures in WebGL (where index 0 has the largest dimension)\r\n */\r\nexport type Mipmaps2D = Mipmaps<TextureSource>;\r\n\r\n/**\r\n * A set of texture mipmaps specifically for cubemap textures in WebGL (where index 0 has the largest dimension)\r\n */\r\nexport type MipmapsCube = Mipmaps<Faces<TextureSource>>;\r\n\r\n/**\r\n * A minimal WebGL cubemap descriptor\r\n */\r\nexport class TextureCube {\r\n\r\n    /**\r\n     * Returns the width of a face of the texture or 0 if not available\r\n     */\r\n    public get Width(): number {\r\n        return (this.source && this.source[0] && this.source[0][0]) ? this.source[0][0].width : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of a face of the texture or 0 if not available\r\n     */\r\n    public get Height(): number {\r\n        return (this.source && this.source[0] && this.source[0][0]) ? this.source[0][0].height : 0;\r\n    }\r\n\r\n    /**\r\n     * constructor\r\n     * @param internalFormat WebGL pixel format for the texture on the GPU\r\n     * @param type WebGL pixel type of the supplied data and texture on the GPU\r\n     * @param source An array containing mipmap levels of faces, where each mipmap level is an array of faces and each face is a TextureSource object\r\n     */\r\n    constructor(public internalFormat: PixelFormat, public type: PixelType, public source: MipmapsCube = []) { }\r\n}\r\n\r\n/**\r\n     * A static class providing methods to aid working with Bablyon textures.\r\n     */\r\nexport class TextureUtils {\r\n\r\n    /**\r\n     * A prefix used when storing a babylon texture object reference on a Spectre texture object\r\n     */\r\n    public static BabylonTextureKeyPrefix = '__babylonTexture_';\r\n\r\n    /**\r\n     * Controls anisotropic filtering for deserialized textures.\r\n     */\r\n    public static MaxAnisotropy = 4;\r\n\r\n    /**\r\n     * Returns a BabylonCubeTexture instance from a Spectre texture cube, subject to sampling parameters.\r\n     * If such a texture has already been requested in the past, this texture will be returned, otherwise a new one will be created.\r\n     * The advantage of this is to enable working with texture objects without the need to initialize on the GPU until desired.\r\n     * @param scene A Babylon Scene instance\r\n     * @param textureCube A Spectre TextureCube object\r\n     * @param parameters WebGL texture sampling parameters\r\n     * @param automaticMipmaps Pass true to enable automatic mipmap generation where possible (requires power of images)\r\n     * @param environment Specifies that the texture will be used as an environment\r\n     * @param singleLod Specifies that the texture will be a singleLod (for environment)\r\n     * @return Babylon cube texture\r\n     */\r\n    public static GetBabylonCubeTexture(scene: Scene, textureCube: TextureCube, automaticMipmaps: boolean, environment = false, singleLod = false): CubeTexture {\r\n        if (!textureCube) { throw new Error(\"no texture cube provided\"); }\r\n\r\n        var parameters: SamplingParameters;\r\n        if (environment) {\r\n            parameters = singleLod ? TextureUtils._EnvironmentSingleMipSampling : TextureUtils._EnvironmentSampling;\r\n        }\r\n        else {\r\n            parameters = {\r\n                magFilter: TextureMagFilter.NEAREST,\r\n                minFilter: TextureMinFilter.NEAREST,\r\n                wrapS: TextureWrapMode.CLAMP_TO_EDGE,\r\n                wrapT: TextureWrapMode.CLAMP_TO_EDGE\r\n            };\r\n        }\r\n\r\n        let key = TextureUtils.BabylonTextureKeyPrefix + parameters.magFilter + '' + parameters.minFilter + '' + parameters.wrapS + '' + parameters.wrapT;\r\n\r\n        let babylonTexture: CubeTexture = (<any>textureCube)[key];\r\n\r\n        if (!babylonTexture) {\r\n\r\n            //initialize babylon texture\r\n            babylonTexture = new CubeTexture('', scene);\r\n            if (environment) {\r\n                babylonTexture.lodGenerationOffset = TextureUtils.EnvironmentLODOffset;\r\n                babylonTexture.lodGenerationScale = TextureUtils.EnvironmentLODScale;\r\n            }\r\n\r\n            babylonTexture.gammaSpace = false;\r\n\r\n            let internalTexture = new InternalTexture(scene.getEngine(), InternalTextureSource.CubeRaw);\r\n            let glTexture = internalTexture._webGLTexture;\r\n            //babylon properties\r\n            internalTexture.isCube = true;\r\n            internalTexture.generateMipMaps = false;\r\n\r\n            babylonTexture._texture = internalTexture;\r\n\r\n            TextureUtils.ApplySamplingParameters(babylonTexture, parameters);\r\n\r\n            let maxMipLevel = automaticMipmaps ? 0 : textureCube.source.length - 1;\r\n            let texturesUploaded = 0;\r\n\r\n            var textureComplete = function() {\r\n                return texturesUploaded === ((maxMipLevel + 1) * 6);\r\n            };\r\n\r\n            var uploadFace = function(i: number, level: number, face: TextureSource) {\r\n                if (!glTexture) { return; }\r\n\r\n                if (i === 0 && level === 0) {\r\n                    internalTexture.width = face.width;\r\n                    internalTexture.height = face.height;\r\n                }\r\n\r\n                let gl = (<any>(scene.getEngine()))._gl;\r\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, glTexture);\r\n                scene.getEngine()._unpackFlipY(false);\r\n                if (face instanceof HTMLElement || face instanceof ImageData) {\r\n                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, textureCube.internalFormat, textureCube.internalFormat, textureCube.type, <any>face);\r\n                } else {\r\n                    let textureData = <TextureData>face;\r\n                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, textureCube.internalFormat, textureData.width, textureData.height, 0, textureData.format, textureCube.type, textureData.data);\r\n                }\r\n\r\n                texturesUploaded++;\r\n\r\n                if (textureComplete()) {\r\n                    //generate mipmaps\r\n                    if (automaticMipmaps) {\r\n                        let w = face.width;\r\n                        let h = face.height;\r\n                        let isPot = (((w !== 0) && (w & (w - 1))) === 0) && (((h !== 0) && (h & (h - 1))) === 0);\r\n                        if (isPot) {\r\n                            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n                        }\r\n                    }\r\n\r\n                    // Upload Separate lods in case there is no support for texture lod.\r\n                    if (environment && !scene.getEngine().getCaps().textureLOD && !singleLod) {\r\n                        const mipSlices = 3;\r\n                        for (let i = 0; i < mipSlices; i++) {\r\n                            let lodKey = TextureUtils.BabylonTextureKeyPrefix + 'lod' + i;\r\n                            let lod: CubeTexture = (<any>textureCube)[lodKey];\r\n\r\n                            //initialize lod texture if it doesn't already exist\r\n                            if (lod == null && textureCube.Width) {\r\n                                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                                let smoothness = i / (mipSlices - 1);\r\n                                let roughness = 1 - smoothness;\r\n                                const kMinimumVariance = 0.0005;\r\n                                let alphaG = roughness * roughness + kMinimumVariance;\r\n                                let microsurfaceAverageSlopeTexels = alphaG * textureCube.Width;\r\n\r\n                                let environmentSpecularLOD = TextureUtils.EnvironmentLODScale * (Scalar.Log2(microsurfaceAverageSlopeTexels)) + TextureUtils.EnvironmentLODOffset;\r\n\r\n                                let maxLODIndex = textureCube.source.length - 1;\r\n                                let mipmapIndex = Math.min(Math.max(Math.round(environmentSpecularLOD), 0), maxLODIndex);\r\n\r\n                                lod = TextureUtils.GetBabylonCubeTexture(scene, new TextureCube(PixelFormat.RGBA, PixelType.UNSIGNED_BYTE, [textureCube.source[mipmapIndex]]), false, true, true);\r\n\r\n                                if (i === 0) {\r\n                                    internalTexture._lodTextureLow = lod;\r\n                                }\r\n                                else if (i === 1) {\r\n                                    internalTexture._lodTextureMid = lod;\r\n                                }\r\n                                else {\r\n                                    internalTexture._lodTextureHigh = lod;\r\n                                }\r\n\r\n                                (<any>textureCube)[lodKey] = lod;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    internalTexture.isReady = true;\r\n                }\r\n\r\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);\r\n                scene.getEngine().resetTextureCache();\r\n            };\r\n\r\n            for (let i = 0; i <= maxMipLevel; i++) {\r\n                let faces = textureCube.source[i];\r\n                for (let j = 0; j < faces.length; j++) {\r\n                    let face = faces[j];\r\n                    if (face instanceof HTMLImageElement && !face.complete) {\r\n                        face.addEventListener('load', () => {\r\n                            uploadFace(j, i, face);\r\n                        }, false);\r\n                    } else {\r\n                        uploadFace(j, i, face);\r\n                    }\r\n                }\r\n            }\r\n\r\n            scene.getEngine().resetTextureCache();\r\n\r\n            babylonTexture.isReady = () => {\r\n                return textureComplete();\r\n            };\r\n\r\n            (<any>textureCube)[key] = babylonTexture;\r\n        }\r\n\r\n        return babylonTexture;\r\n    }\r\n\r\n    /**\r\n     * Applies Spectre SamplingParameters to a Babylon texture by directly setting texture parameters on the internal WebGLTexture as well as setting Babylon fields\r\n     * @param babylonTexture Babylon texture to apply texture to (requires the Babylon texture has an initialize _texture field)\r\n     * @param parameters Spectre SamplingParameters to apply\r\n     */\r\n    public static ApplySamplingParameters(babylonTexture: BaseTexture, parameters: SamplingParameters) {\r\n        let scene = babylonTexture.getScene();\r\n        if (!scene) { return; }\r\n        let gl = (<any>(scene.getEngine()))._gl;\r\n\r\n        let target = babylonTexture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;\r\n\r\n        let internalTexture = babylonTexture._texture;\r\n        if (!internalTexture) { return; }\r\n        let glTexture = internalTexture._webGLTexture;\r\n        gl.bindTexture(target, glTexture);\r\n\r\n        if (parameters.magFilter != null) { gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, parameters.magFilter); }\r\n        if (parameters.minFilter != null) { gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, parameters.minFilter); }\r\n        if (parameters.wrapS != null) { gl.texParameteri(target, gl.TEXTURE_WRAP_S, parameters.wrapS); }\r\n        if (parameters.wrapT != null) { gl.texParameteri(target, gl.TEXTURE_WRAP_T, parameters.wrapT); }\r\n\r\n        //set babylon wrap modes from sampling parameter\r\n        switch (parameters.wrapS) {\r\n            case TextureWrapMode.REPEAT: babylonTexture.wrapU = Texture.WRAP_ADDRESSMODE; break;\r\n            case TextureWrapMode.CLAMP_TO_EDGE: babylonTexture.wrapU = Texture.CLAMP_ADDRESSMODE; break;\r\n            case TextureWrapMode.MIRRORED_REPEAT: babylonTexture.wrapU = Texture.MIRROR_ADDRESSMODE; break;\r\n            default: babylonTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        }\r\n\r\n        switch (parameters.wrapT) {\r\n            case TextureWrapMode.REPEAT: babylonTexture.wrapV = Texture.WRAP_ADDRESSMODE; break;\r\n            case TextureWrapMode.CLAMP_TO_EDGE: babylonTexture.wrapV = Texture.CLAMP_ADDRESSMODE; break;\r\n            case TextureWrapMode.MIRRORED_REPEAT: babylonTexture.wrapV = Texture.MIRROR_ADDRESSMODE; break;\r\n            default: babylonTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        }\r\n\r\n        if (parameters.maxAnisotropy != null && parameters.maxAnisotropy > 1) {\r\n            let anisotropicExt = gl.getExtension('EXT_texture_filter_anisotropic');\r\n            if (anisotropicExt) {\r\n                let maxAnisotropicSamples = gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\r\n                let maxAnisotropy = Math.min(parameters.maxAnisotropy, maxAnisotropicSamples);\r\n                gl.texParameterf(target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);\r\n                babylonTexture.anisotropicFilteringLevel = maxAnisotropy;\r\n            }\r\n        }\r\n\r\n        gl.bindTexture(target, null);\r\n        scene.getEngine().resetTextureCache();\r\n    }\r\n\r\n    private static _EnvironmentSampling: SamplingParameters = {\r\n        magFilter: TextureMagFilter.LINEAR,\r\n        minFilter: TextureMinFilter.LINEAR_MIPMAP_LINEAR,\r\n        wrapS: TextureWrapMode.CLAMP_TO_EDGE,\r\n        wrapT: TextureWrapMode.CLAMP_TO_EDGE,\r\n        maxAnisotropy: 1\r\n    };\r\n\r\n    private static _EnvironmentSingleMipSampling: SamplingParameters = {\r\n        magFilter: TextureMagFilter.LINEAR,\r\n        minFilter: TextureMinFilter.LINEAR,\r\n        wrapS: TextureWrapMode.CLAMP_TO_EDGE,\r\n        wrapT: TextureWrapMode.CLAMP_TO_EDGE,\r\n        maxAnisotropy: 1\r\n    };\r\n\r\n    //from \"/Internal/Lighting.EnvironmentFilterScale\" in Engine/*/Configuration.cpp\r\n    /**\r\n     * Environment preprocessing dedicated value (Internal Use or Advanced only).\r\n     */\r\n    public static EnvironmentLODScale = 0.8;\r\n    /**\r\n     * Environment preprocessing dedicated value (Internal Use or Advanced only)..\r\n     */\r\n    public static EnvironmentLODOffset = 1.0;\r\n}"]}