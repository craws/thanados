import { Observable } from '@babylonjs/core/Misc/observable';
/**
 * The viewer manager is the container for all viewers currently registered on this page.
 * It is possible to have more than one viewer on a single page.
 */
var ViewerManager = /** @class */ (function () {
    function ViewerManager() {
        this._viewers = {};
        this.onViewerAddedObservable = new Observable();
        this.onViewerRemovedObservable = new Observable();
    }
    /**
     * Adding a new viewer to the viewer manager and start tracking it.
     * @param viewer the viewer to add
     */
    ViewerManager.prototype.addViewer = function (viewer) {
        this._viewers[viewer.getBaseId()] = viewer;
        this._onViewerAdded(viewer);
    };
    /**
     * remove a viewer from the viewer manager
     * @param viewer the viewer to remove
     */
    ViewerManager.prototype.removeViewer = function (viewer) {
        var id = viewer.getBaseId();
        delete this._viewers[id];
        this.onViewerRemovedObservable.notifyObservers(id);
    };
    /**
     * Get a viewer by its baseId (if the container element has an ID, it is the this is. if not, a random id was assigned)
     * @param id the id of the HTMl element (or the viewer's, if none provided)
     */
    ViewerManager.prototype.getViewerById = function (id) {
        return this._viewers[id];
    };
    /**
     * Get a viewer using a container element
     * @param element the HTML element to search viewers associated with
     */
    ViewerManager.prototype.getViewerByHTMLElement = function (element) {
        for (var id in this._viewers) {
            if (this._viewers[id].containerElement === element) {
                return this.getViewerById(id);
            }
        }
    };
    /**
     * Get a promise that will fullfil when this viewer was initialized.
     * Since viewer initialization and template injection is asynchronous, using the promise will guaranty that
     * you will get the viewer after everything was already configured.
     * @param id the viewer id to find
     */
    ViewerManager.prototype.getViewerPromiseById = function (id) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var localViewer = _this.getViewerById(id);
            if (localViewer) {
                return resolve(localViewer);
            }
            var viewerFunction = function (viewer) {
                if (viewer.getBaseId() === id) {
                    resolve(viewer);
                    _this.onViewerAddedObservable.removeCallback(viewerFunction);
                }
            };
            _this.onViewerAddedObservable.add(viewerFunction);
        });
    };
    ViewerManager.prototype._onViewerAdded = function (viewer) {
        this.onViewerAdded && this.onViewerAdded(viewer);
        this.onViewerAddedObservable.notifyObservers(viewer);
    };
    /**
     * dispose the manager and all of its associated viewers
     */
    ViewerManager.prototype.dispose = function () {
        delete this._onViewerAdded;
        for (var id in this._viewers) {
            this._viewers[id].dispose();
        }
        this.onViewerAddedObservable.clear();
        this.onViewerRemovedObservable.clear();
    };
    return ViewerManager;
}());
export { ViewerManager };
export var viewerManager = new ViewerManager();
//# sourceMappingURL=viewerManager.js.map